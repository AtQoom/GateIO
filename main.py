#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ONDO Ïó≠Î∞©Ìñ• Í∑∏Î¶¨Îìú Îß§Îß§ ÏãúÏä§ÌÖú v17.0-FINAL
- TP Í∏∞Î∞ò Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ±
- ÎìÄÏñº TP (ÌèâÎã®Í∞Ä/Í∞úÎ≥Ñ)
- Ìó§Ïßï Ìè¨ÏßÄÏÖò: Ìï≠ÏÉÅ ÌèâÎã®Í∞Ä TP
- Ï£ºÎ†• Ìè¨ÏßÄÏÖò: ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º Ïãú Í∞úÎ≥Ñ TP
- Î™®Îì† Ï†ÑÏ≤¥ Ï≤≠ÏÇ∞ Ïãú Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ±
- ÏòàÏô∏ Ï≤òÎ¶¨ Í∞ïÌôî
- Í∞úÎ≥Ñ Ïø®Îã§Ïö¥
"""

import os
import time
import asyncio
import threading
import logging
import json
from decimal import Decimal, ROUND_DOWN
from flask import Flask, request, jsonify
from gate_api import ApiClient, Configuration, FuturesApi, FuturesOrder, UnifiedApi
import websockets
import pandas as pd
import numpy as np

logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

# =============================================================================
# ÏÑ§Ï†ï
# =============================================================================

SETTLE = "usdt"
SYMBOL = "ONDO_USDT"
CONTRACT_SIZE = Decimal("1")

GRID_GAP_PCT = Decimal("0.16") / Decimal("100")  # 0.21%
TP_GAP_PCT = Decimal("0.16") / Decimal("100")    # 0.21%
HEDGE_RATIO = Decimal("0.2")  # Ìó§Ïßï 0.3Î∞∞
THRESHOLD_RATIO = Decimal("2.0")  # ÏûÑÍ≥ÑÍ∞í 2Î∞∞

# API ÏÑ§Ï†ï
API_KEY = os.environ.get("API_KEY", "")
API_SECRET = os.environ.get("API_SECRET", "")
if not API_KEY or not API_SECRET:
    logger.critical("API ÌÇ§ ÏóÜÏùå")
    exit(1)

config = Configuration(key=API_KEY, secret=API_SECRET)
client = ApiClient(config)
api = FuturesApi(client)
unified_api = UnifiedApi(client)

# Ï†ÑÏó≠ Î≥ÄÏàò
position_lock = threading.RLock()
position_state = {}
latest_prices = {}
entry_history = {}
tp_orders = {}
tp_type = {}
INITIAL_BALANCE = Decimal("0")

app = Flask(__name__)

# =============================================================================
# Ïú†Ìã∏Î¶¨Ìã∞
# =============================================================================

def log_debug(label, msg="", exc_info=False):
    """Î°úÍ∑∏ Ï∂úÎ†•"""
    if exc_info:
        logger.error(f"[{label}] {msg}", exc_info=True)
    else:
        logger.info(f"[{label}] {msg}")


def get_available_balance(show_log=False):
    """ÏÇ¨Ïö© Í∞ÄÎä• ÏûîÍ≥† Ï°∞Ìöå (Unified/Futures)"""
    try:
        # Unified Account
        try:
            unified_account = unified_api.list_unified_accounts()
            if hasattr(unified_account, 'balances') and unified_account.balances:
                balances = unified_account.balances
                if isinstance(balances, dict) and "USDT" in balances:
                    usdt_data = balances["USDT"]
                    try:
                        if isinstance(usdt_data, dict):
                            available_str = str(usdt_data.get("available", "0"))
                        else:
                            available_str = str(getattr(usdt_data, "available", "0"))
                        usdt_balance = float(available_str)
                        if usdt_balance > 0:
                            if show_log:
                                log_debug("üí∞ ÏûîÍ≥† (Unified)", f"{usdt_balance:.2f} USDT")
                            return usdt_balance
                    except:
                        pass
        except:
            pass
        
        # Futures Account
        try:
            account = api.list_futures_accounts(settle=SETTLE)
            if account:
                available = float(getattr(account, "available", "0"))
                if available > 0:
                    if show_log:
                        log_debug("üí∞ ÏûîÍ≥† (Futures)", f"{available:.2f} USDT")
                    return available
        except:
            pass
        
        return 0.0
    except:
        return 0.0


def get_candles(symbol, interval="10s", limit=600):
    """Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
    try:
        candles = api.list_futures_candlesticks(SETTLE, contract=symbol, interval=interval, limit=limit)
        if not candles:
            return None
        
        df = pd.DataFrame([{
            'time': int(c.t),
            'open': float(c.o),
            'high': float(c.h),
            'low': float(c.l),
            'close': float(c.c),
            'volume': float(c.v)
        } for c in candles])
        
        return df
    except Exception as e:
        log_debug("‚ùå Ï∫îÎì§ Ï°∞Ìöå Ïã§Ìå®", str(e))
        return None


def calculate_obv_macd(symbol):
    """Shadow OBV MACD Í≥ÑÏÇ∞"""
    try:
        df = get_candles(symbol, interval="10s", limit=600)
        if df is None or len(df) < 50:
            return Decimal("0")
        
        window_len = 28
        v_len = 14
        ma_len = 9
        slow_length = 26
        
        price_spread = df['high'] - df['low']
        price_spread_std = price_spread.rolling(window=window_len, min_periods=1).std().fillna(0)
        
        price_change = df['close'].diff().fillna(0)
        volume_signed = np.sign(price_change) * df['volume']
        v = volume_signed.cumsum()
        
        smooth = v.rolling(window=v_len, min_periods=1).mean()
        v_diff = v - smooth
        v_spread = v_diff.rolling(window=window_len, min_periods=1).std().fillna(1)
        v_spread = v_spread.replace(0, 1)
        
        shadow = (v_diff / v_spread) * price_spread_std
        
        out = pd.Series(index=df.index, dtype=float)
        for i in range(len(df)):
            if shadow.iloc[i] > 0:
                out.iloc[i] = df['high'].iloc[i] + shadow.iloc[i]
            else:
                out.iloc[i] = df['low'].iloc[i] + shadow.iloc[i]
        
        ma1 = out.ewm(span=ma_len, adjust=False).mean()
        ma2 = ma1.ewm(span=ma_len, adjust=False).mean()
        dema = 2 * ma1 - ma2
        
        slow_ma = df['close'].ewm(span=slow_length, adjust=False).mean()
        macd = dema - slow_ma
        
        final_value = macd.iloc[-1]
        
        if pd.isna(final_value) or np.isinf(final_value):
            return Decimal("0")
        
        return Decimal(str(round(float(final_value), 6)))
        
    except Exception as e:
        log_debug("‚ùå OBV MACD Ïò§Î•ò", str(e), exc_info=True)
        return Decimal("0")


def calculate_grid_qty(current_price):
    """Í∑∏Î¶¨Îìú ÏàòÎüâ Í≥ÑÏÇ∞ (OBV MACD Í∏∞Î∞ò 0.3~0.6Î∞∞)"""
    try:
        if INITIAL_BALANCE <= 0:
            return 1
        
        obv_macd = calculate_obv_macd(SYMBOL)
        abs_val = abs(float(obv_macd * 1000))
        
        if abs_val < 5:
            leverage = Decimal("0.2")
        elif abs_val < 10:
            leverage = Decimal("0.22")
        elif abs_val < 20:
            leverage = Decimal("0.24")
        elif abs_val < 30:
            leverage = Decimal("0.26")
        elif abs_val < 40:
            leverage = Decimal("0.28")
        elif abs_val < 50:
            leverage = Decimal("0.3")
        elif abs_val < 60:
            leverage = Decimal("0.32")
        elif abs_val < 70:
            leverage = Decimal("0.34")
        elif abs_val < 80:
            leverage = Decimal("0.36")
        elif abs_val < 90:
            leverage = Decimal("0.38")
        elif abs_val < 100:
            leverage = Decimal("0.40")            
        else:
            leverage = Decimal("0.5")
        
        qty = int((INITIAL_BALANCE * leverage) / (current_price * CONTRACT_SIZE))
        return max(1, qty)
    except Exception as e:
        log_debug("‚ùå Í∑∏Î¶¨Îìú ÏàòÎüâ Ïò§Î•ò", str(e))
        return 1


def calculate_position_value(qty, price):
    """Ìè¨ÏßÄÏÖò Í∞ÄÏπò Í≥ÑÏÇ∞"""
    return qty * price * CONTRACT_SIZE

# =============================================================================
# Ìè¨ÏßÄÏÖò Í¥ÄÎ¶¨
# =============================================================================

def update_position_state(symbol, retry=5, show_log=False):
    """Ìè¨ÏßÄÏÖò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (ÏÑ†ÌÉùÏ†Å Î°úÍ∑∏)"""
    for attempt in range(retry):
        try:
            positions = api.list_positions(SETTLE)
            
            with position_lock:
                if symbol not in position_state:
                    position_state[symbol] = {"long": {}, "short": {}}
                
                long_size = Decimal("0")
                long_price = Decimal("0")
                short_size = Decimal("0")
                short_price = Decimal("0")
                
                for p in positions:
                    if p.contract != symbol:
                        continue
                        
                    size = abs(Decimal(str(p.size)))
                    entry_price = Decimal(str(p.entry_price)) if p.entry_price else Decimal("0")
                    
                    if p.size > 0:
                        long_size = size
                        long_price = entry_price
                    elif p.size < 0:
                        short_size = size
                        short_price = entry_price
                
                position_state[symbol]["long"] = {"size": long_size, "price": long_price}
                position_state[symbol]["short"] = {"size": short_size, "price": short_price}
                
                if show_log:
                    log_debug("üîç Ìè¨ÏßÄÏÖò ÏµúÏ¢Ö", f"Î°±:{long_size}@{long_price:.4f} Ïàè:{short_size}@{short_price:.4f}")
                
                return True
                
        except Exception as e:
            if attempt < retry - 1:
                log_debug(f"‚ö†Ô∏è Ìè¨ÏßÄÏÖò Ï°∞Ìöå Ïû¨ÏãúÎèÑ {attempt + 1}/{retry}", str(e))
                time.sleep(0.5)
            else:
                log_debug("‚ùå Ìè¨ÏßÄÏÖò ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®", str(e), exc_info=True)
                return False


def record_entry(symbol, side, price, qty):
    """ÏßÑÏûÖ Í∏∞Î°ù Ï†ÄÏû•"""
    if symbol not in entry_history:
        entry_history[symbol] = {"long": [], "short": []}
    
    entry_history[symbol][side].append({
        "price": Decimal(str(price)),
        "qty": Decimal(str(qty)),
        "timestamp": time.time()
    })
    
    log_debug("üìù ÏßÑÏûÖ Í∏∞Î°ù", f"{symbol}_{side} {qty}Í≥ÑÏïΩ @ {price:.4f}")

# =============================================================================
# Ï£ºÎ¨∏ Í¥ÄÎ¶¨
# =============================================================================

def cancel_grid_orders(symbol):
    """Í∑∏Î¶¨Îìú Ï£ºÎ¨∏Îßå Ï∑®ÏÜå (TP Ïú†ÏßÄ)"""
    for retry in range(2):
        try:
            orders = api.list_futures_orders(SETTLE, contract=symbol, status="open")
            cancelled_count = 0
            cancelled_ids = []
            
            for order in orders:
                try:
                    if not order.is_reduce_only:
                        api.cancel_futures_order(SETTLE, order.id)
                        cancelled_count += 1
                        cancelled_ids.append(f"ID:{order.id} {order.size}@{order.price}")
                        time.sleep(0.1)
                except Exception as e:
                    log_debug("‚ö†Ô∏è Ï£ºÎ¨∏ Ï∑®ÏÜå Ïã§Ìå®", f"ID:{order.id}")
            
            if cancelled_count > 0:
                log_debug("‚úÖ Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÏôÑÎ£å", f"{cancelled_count}Í∞ú Ï£ºÎ¨∏")
                for order_info in cancelled_ids:
                    log_debug("  „Ñ¥ Ï∑®ÏÜå", order_info)
            else:
                log_debug("‚ÑπÔ∏è Ï∑®ÏÜåÌï† Í∑∏Î¶¨Îìú ÏóÜÏùå", "")
            break
            
        except Exception as e:
            if retry < 1:
                log_debug("‚ö†Ô∏è Í∑∏Î¶¨Îìú Ï∑®ÏÜå Ïû¨ÏãúÎèÑ", str(e))
                time.sleep(0.3)
            else:
                log_debug("‚ùå Í∑∏Î¶¨Îìú Ï∑®ÏÜå Ïã§Ìå®", str(e))


def cancel_tp_orders(symbol, side):
    """TP Ï£ºÎ¨∏ Ï∑®ÏÜå (Í±∞ÎûòÏÜå Ï£ºÎ¨∏ ÏßÅÏ†ë ÌôïÏù∏)"""
    try:
        cancelled_count = 0
        
        orders = api.list_futures_orders(SETTLE, contract=symbol, status="open")
        
        for order in orders:
            if not order.is_reduce_only:
                continue
            
            if side == "long" and order.size < 0:
                for retry in range(3):
                    try:
                        api.cancel_futures_order(SETTLE, order.id)
                        log_debug("‚úÖ TP Ï∑®ÏÜå", f"{symbol}_{side} ID:{order.id} {order.size}@{order.price}")
                        cancelled_count += 1
                        break
                    except Exception as e:
                        if retry < 2:
                            time.sleep(0.3)
                        else:
                            log_debug("‚ö†Ô∏è TP Ï∑®ÏÜå Ïã§Ìå®", f"ID:{order.id}")
            
            elif side == "short" and order.size > 0:
                for retry in range(3):
                    try:
                        api.cancel_futures_order(SETTLE, order.id)
                        log_debug("‚úÖ TP Ï∑®ÏÜå", f"{symbol}_{side} ID:{order.id} {order.size}@{order.price}")
                        cancelled_count += 1
                        break
                    except Exception as e:
                        if retry < 2:
                            time.sleep(0.3)
                        else:
                            log_debug("‚ö†Ô∏è TP Ï∑®ÏÜå Ïã§Ìå®", f"ID:{order.id}")
        
        if symbol in tp_orders and side in tp_orders[symbol]:
            tp_orders[symbol][side] = []
        
        if cancelled_count > 0:
            log_debug("‚úÖ TP Ï†ÑÏ≤¥ Ï∑®ÏÜå", f"{symbol}_{side} {cancelled_count}Í∞ú")
        else:
            log_debug("‚ÑπÔ∏è Ï∑®ÏÜåÌï† TP ÏóÜÏùå", f"{symbol}_{side}")
            
    except Exception as e:
        log_debug("‚ùå TP Ï∑®ÏÜå Ïò§Î•ò", str(e), exc_info=True)

# =============================================================================
# TP Í¥ÄÎ¶¨
# =============================================================================

def place_average_tp_order(symbol, side, price, qty, retry=3):
    """ÌèâÎã®Í∞Ä TP ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏ (Ïû¨ÏãúÎèÑ)"""
    for attempt in range(retry):
        try:
            if side == "long":
                tp_price = price * (Decimal("1") + TP_GAP_PCT)
                order_size = -int(qty)
            else:
                tp_price = price * (Decimal("1") - TP_GAP_PCT)
                order_size = int(qty)
            
            order = FuturesOrder(
                contract=symbol,
                size=order_size,
                price=str(round(float(tp_price), 4)),
                tif="gtc",
                reduce_only=True
            )
            
            result = api.create_futures_order(SETTLE, order)
            
            if symbol not in tp_orders:
                tp_orders[symbol] = {"long": [], "short": []}
            
            tp_orders[symbol][side].append({
                "order_id": result.id,
                "tp_price": tp_price,
                "qty": Decimal(str(qty)),
                "type": "average"
            })
            
            log_debug("‚úÖ ÌèâÎã® TP", f"{symbol}_{side} {qty}Í≥ÑÏïΩ TP:{float(tp_price):.4f}")
            
            return True
            
        except Exception as e:
            if attempt < retry - 1:
                log_debug(f"‚ö†Ô∏è TP Ïû¨ÏãúÎèÑ {attempt + 1}/{retry}", str(e))
                time.sleep(0.5)
            else:
                log_debug("‚ùå ÌèâÎã® TP Ïã§Ìå®", str(e), exc_info=True)
                return False


def place_individual_tp_orders(symbol, side, entries):
    """Í∞úÎ≥Ñ ÏßÑÏûÖÎ≥Ñ TP ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏"""
    try:
        if not entries:
            log_debug("‚ö†Ô∏è ÏßÑÏûÖ Í∏∞Î°ù ÏóÜÏùå", f"{symbol}_{side} - Í∞úÎ≥Ñ TP ÏÉùÏÑ± Î∂àÍ∞Ä")
            return
        
        log_debug("üìå Í∞úÎ≥Ñ TP ÏÉùÏÑ± ÏãúÏûë", f"{symbol}_{side} {len(entries)}Í∞ú ÏßÑÏûÖ")
        
        for idx, entry in enumerate(entries):
            entry_price = entry["price"]
            qty = entry["qty"]
            
            if side == "long":
                tp_price = entry_price * (Decimal("1") + TP_GAP_PCT)
                order_size = -int(qty)
            else:
                tp_price = entry_price * (Decimal("1") - TP_GAP_PCT)
                order_size = int(qty)
            
            order = FuturesOrder(
                contract=symbol,
                size=order_size,
                price=str(round(float(tp_price), 4)),
                tif="gtc",
                reduce_only=True
            )
            
            result = api.create_futures_order(SETTLE, order)
            
            if symbol not in tp_orders:
                tp_orders[symbol] = {"long": [], "short": []}
            
            tp_orders[symbol][side].append({
                "order_id": result.id,
                "entry_price": entry_price,
                "tp_price": tp_price,
                "qty": Decimal(str(qty)),
                "type": "individual"
            })
            
            log_debug(f"  „Ñ¥ [{idx+1}/{len(entries)}]", 
                     f"{qty}Í≥ÑÏïΩ ÏßÑÏûÖ:{float(entry_price):.4f} ‚Üí TP:{float(tp_price):.4f} ID:{result.id}")
            
            time.sleep(0.1)
        
        log_debug("‚úÖ Í∞úÎ≥Ñ TP ÏÉùÏÑ± ÏôÑÎ£å", f"{symbol}_{side} {len(entries)}Í∞ú")
            
    except Exception as e:
        log_debug("‚ùå Í∞úÎ≥Ñ TP Ïã§Ìå®", str(e), exc_info=True)


def check_and_update_tp_mode_locked(symbol, side, size, price):
    """ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨ Î∞è TP Î™®Îìú Ï†ÑÌôò (Ìó§Ïßï Ìè¨ÏßÄÏÖòÏùÄ Ìï≠ÏÉÅ ÌèâÎã®Í∞Ä TP)"""
    try:
        if size == 0:
            log_debug("‚ö†Ô∏è Ìè¨ÏßÄÏÖò 0", f"{symbol}_{side} size=0 - TP ÏÉùÏÑ± Î∂àÍ∞Ä")
            return
        
        # Ïã§Ï†ú Í±∞ÎûòÏÜå Ï£ºÎ¨∏ ÌôïÏù∏
        existing_tp_qty = Decimal("0")
        try:
            orders = api.list_futures_orders(SETTLE, contract=symbol, status="open")
            for order in orders:
                if order.is_reduce_only:
                    if (side == "long" and order.size < 0) or (side == "short" and order.size > 0):
                        order_size = abs(order.size)
                        existing_tp_qty += Decimal(str(order_size))
                        log_debug(f"üîç TP Î∞úÍ≤¨", f"{side} {order_size}Í≥ÑÏïΩ @ {order.price}")
        except Exception as e:
            log_debug("‚ö†Ô∏è TP Ï£ºÎ¨∏ Ï°∞Ìöå Ïã§Ìå®", str(e))
        
        # ÎîïÏÖîÎÑàÎ¶¨ ÏàòÎüâÍ≥º ÎπÑÍµê
        dict_tp_qty = Decimal("0")
        if symbol in tp_orders and side in tp_orders[symbol]:
            for tp in tp_orders[symbol][side]:
                dict_tp_qty += tp.get("qty", Decimal("0"))
        
        # Î∂àÏùºÏπò Ïãú ÎîïÏÖîÎÑàÎ¶¨ Ï†ïÎ¶¨
        if existing_tp_qty != dict_tp_qty:
            log_debug("‚ö†Ô∏è TP ÏàòÎüâ Î∂àÏùºÏπò", 
                     f"{symbol}_{side} Í±∞ÎûòÏÜå:{existing_tp_qty} vs ÎîïÏÖîÎÑàÎ¶¨:{dict_tp_qty}")
            if symbol in tp_orders and side in tp_orders[symbol]:
                tp_orders[symbol][side] = []
        
        # TP Î∂ÄÏ°±ÌïòÎ©¥ Î¨¥Ï°∞Í±¥ Ïû¨ÏÉùÏÑ±
        if existing_tp_qty < size:
            log_debug("‚ö†Ô∏è TP Î∂ÄÏ°±", f"{symbol}_{side} Í∏∞Ï°¥:{existing_tp_qty} < Ìè¨ÏßÄÏÖò:{size}")
            
            cancel_tp_orders(symbol, side)
            time.sleep(0.5)
            
            success = place_average_tp_order(symbol, side, price, size, retry=3)
            
            if success:
                if symbol not in tp_type:
                    tp_type[symbol] = {"long": "average", "short": "average"}
                tp_type[symbol][side] = "average"
            else:
                log_debug("‚ùå TP ÏÉùÏÑ± Ïã§Ìå®", f"{symbol}_{side}")
            
            return
        
        # TP Ï¥àÍ≥ºÌïòÎ©¥ Ïû¨ÏÉùÏÑ±
        if existing_tp_qty > size:
            log_debug("‚ö†Ô∏è TP Ï¥àÍ≥º", f"{symbol}_{side} Í∏∞Ï°¥:{existing_tp_qty} > Ìè¨ÏßÄÏÖò:{size}")
            
            cancel_tp_orders(symbol, side)
            time.sleep(0.5)
            
            success = place_average_tp_order(symbol, side, price, size, retry=3)
            
            if success:
                if symbol not in tp_type:
                    tp_type[symbol] = {"long": "average", "short": "average"}
                tp_type[symbol][side] = "average"
            else:
                log_debug("‚ùå TP ÏÉùÏÑ± Ïã§Ìå®", f"{symbol}_{side}")
            
            return
        
        # TP Ï†ïÌôïÌûà ÏùºÏπò
        log_debug("‚úÖ TP Ï†ïÌôï", f"{symbol}_{side} Í∏∞Ï°¥:{existing_tp_qty} == Ìè¨ÏßÄÏÖò:{size}")
        
        # ‚≠ê‚≠ê‚≠ê Ìó§Ïßï Ìè¨ÏßÄÏÖò Ï≤¥ÌÅ¨ (ÏûÑÍ≥ÑÍ∞íÏùò 1.5Î∞∞ ÎØ∏Îßå)
        position_value = calculate_position_value(size, price)
        hedge_threshold = INITIAL_BALANCE * HEDGE_RATIO * Decimal("1.5")
        
        if position_value < hedge_threshold:
            log_debug("‚ÑπÔ∏è Ìó§Ïßï Ìè¨ÏßÄÏÖò", 
                     f"{symbol}_{side} {float(position_value):.2f} < {float(hedge_threshold):.2f} (Í∞úÎ≥Ñ TP Ï†ÅÏö© Ï†úÏô∏)")
            
            # ‚≠ê Ìó§Ïßï Ìè¨ÏßÄÏÖòÏùÄ Ìï≠ÏÉÅ ÌèâÎã®Í∞Ä TP Ïú†ÏßÄ
            current_type = tp_type.get(symbol, {}).get(side, "average")
            if current_type == "individual":
                log_debug("üîÑ Ìó§Ïßï ‚Üí ÌèâÎã®Í∞Ä Ï†ÑÌôò", f"{symbol}_{side}")
                
                cancel_tp_orders(symbol, side)
                time.sleep(0.5)
                
                success = place_average_tp_order(symbol, side, price, size, retry=3)
                
                if success:
                    if symbol not in tp_type:
                        tp_type[symbol] = {"long": "average", "short": "average"}
                    tp_type[symbol][side] = "average"
            
            return
        
        # ‚≠ê Ï£ºÎ†• Ìè¨ÏßÄÏÖòÎßå ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
        threshold_value = INITIAL_BALANCE * THRESHOLD_RATIO
        current_type = tp_type.get(symbol, {}).get(side, "average")
        
        if position_value > threshold_value:
            if current_type != "individual":
                log_debug("‚ö†Ô∏è ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º (Ï£ºÎ†•)", 
                         f"{symbol}_{side} {float(position_value):.2f} > {float(threshold_value):.2f}")
                
                cancel_tp_orders(symbol, side)
                time.sleep(0.5)
                
                entries = entry_history.get(symbol, {}).get(side, [])
                if entries:
                    log_debug("üìã ÏßÑÏûÖ Í∏∞Î°ù ÌôïÏù∏", f"{symbol}_{side} {len(entries)}Í∞ú ÏßÑÏûÖ")
                    
                    place_individual_tp_orders(symbol, side, entries)
                    
                    if symbol not in tp_type:
                        tp_type[symbol] = {"long": "average", "short": "average"}
                    tp_type[symbol][side] = "individual"
                    
                    log_debug("‚úÖ Í∞úÎ≥Ñ TP Ï†ÑÌôò ÏôÑÎ£å (Ï£ºÎ†•)", f"{symbol}_{side}")
                else:
                    log_debug("‚ö†Ô∏è ÏßÑÏûÖ Í∏∞Î°ù ÏóÜÏùå", f"{symbol}_{side} - Í∞úÎ≥Ñ TP ÏÉùÏÑ± Î∂àÍ∞Ä")
                    
                    if symbol not in tp_type:
                        tp_type[symbol] = {"long": "average", "short": "average"}
                    tp_type[symbol][side] = "average"
        
    except Exception as e:
        log_debug("‚ùå TP Î™®Îìú Ï≤¥ÌÅ¨ Ïò§Î•ò", str(e), exc_info=True)


def refresh_tp_orders(symbol):
    """TP Ï£ºÎ¨∏ ÏÉàÎ°úÍ≥†Ïπ® (API ÏßÄÏó∞ ÎåÄÏùë Í∞ïÌôî)"""
    try:
        log_debug("üîÑ TP ÏÉàÎ°úÍ≥†Ïπ® ÏãúÏûë", symbol)
        
        for retry in range(5):
            if update_position_state(symbol):
                break
            log_debug(f"‚ö†Ô∏è Ìè¨ÏßÄÏÖò Ï°∞Ìöå Ïû¨ÏãúÎèÑ {retry + 1}/5", "")
            time.sleep(0.5)
        else:
            log_debug("‚ùå Ìè¨ÏßÄÏÖò Ï°∞Ìöå Ïã§Ìå®", "TP ÏÉàÎ°úÍ≥†Ïπ® Ï§ëÎã®")
            return
        
        time.sleep(1.0)
        update_position_state(symbol)
        time.sleep(0.5)
        
        with position_lock:
            for side in ["long", "short"]:
                pos = position_state.get(symbol, {}).get(side, {})
                size = pos.get("size", Decimal("0"))
                price = pos.get("price", Decimal("0"))
                
                log_debug(f"üîç Ìè¨ÏßÄÏÖò Ï≤¥ÌÅ¨", f"{side} size:{size} price:{price:.4f}")
                
                if size > 0:
                    check_and_update_tp_mode_locked(symbol, side, size, price)
                    time.sleep(0.3)
                else:
                    log_debug(f"‚ö†Ô∏è Ìè¨ÏßÄÏÖò ÏóÜÏùå", f"{side} size=0")
                    
    except Exception as e:
        log_debug("‚ùå TP ÏÉàÎ°úÍ≥†Ïπ® Ïò§Î•ò", str(e), exc_info=True)


def emergency_tp_fix(symbol):
    """Í∏¥Í∏â TP ÏàòÏ†ï (ÏàòÎèô Ïã§ÌñâÏö©)"""
    try:
        log_debug("üö® Í∏¥Í∏â TP ÏàòÏ†ï ÏãúÏûë", symbol)
        
        update_position_state(symbol, show_log=True)
        
        for side in ["long", "short"]:
            pos = position_state.get(symbol, {}).get(side, {})
            size = pos.get("size", Decimal("0"))
            price = pos.get("price", Decimal("0"))
            
            if size > 0:
                log_debug(f"üîß {side} TP Í∞ïÏ†ú ÏÉùÏÑ±", f"{size}Í≥ÑÏïΩ @ {price}")
                
                cancel_tp_orders(symbol, side)
                time.sleep(0.5)
                
                place_average_tp_order(symbol, side, price, size, retry=3)
                
    except Exception as e:
        log_debug("‚ùå Í∏¥Í∏â TP ÏàòÏ†ï Ïã§Ìå®", str(e), exc_info=True)

# =============================================================================
# Í∑∏Î¶¨Îìú Í¥ÄÎ¶¨
# =============================================================================

def initialize_grid(base_price=None, skip_check=False):
    """Í∑∏Î¶¨Îìú Ï¥àÍ∏∞Ìôî (ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏)"""
    try:
        if not skip_check:
            orders = api.list_futures_orders(SETTLE, contract=SYMBOL, status="open")
            grid_orders = [o for o in orders if not o.is_reduce_only]
            if grid_orders:
                log_debug("‚ö†Ô∏è Í∏∞Ï°¥ Í∑∏Î¶¨Îìú ÏûàÏùå", f"{len(grid_orders)}Í∞ú")
                
                for order in grid_orders:
                    log_debug("  „Ñ¥ Í∑∏Î¶¨Îìú", f"ID:{order.id} size:{order.size} price:{order.price}")
                
                log_debug("‚ö†Ô∏è Í∑∏Î¶¨Îìú ÏÉùÏÑ± Ï§ëÎã®", "skip_check=TrueÎ°ú Ìò∏Ï∂ú ÌïÑÏöî")
                return
        else:
            log_debug("üéØ Í∑∏Î¶¨Îìú Í∞ïÏ†ú ÏÉùÏÑ±", "skip_check=True")
        
        if base_price is None:
            ticker = api.list_futures_tickers(SETTLE, contract=SYMBOL)
            if not ticker:
                return
            base_price = Decimal(str(ticker[0].last))
        
        obv_macd = calculate_obv_macd(SYMBOL)
        
        upper_price = float(base_price * (Decimal("1") + GRID_GAP_PCT))
        lower_price = float(base_price * (Decimal("1") - GRID_GAP_PCT))
        
        if obv_macd >= 0:
            short_qty = calculate_grid_qty(base_price)
            long_qty = max(1, int((INITIAL_BALANCE * HEDGE_RATIO) / (base_price * CONTRACT_SIZE)))
        else:
            long_qty = calculate_grid_qty(base_price)
            short_qty = max(1, int((INITIAL_BALANCE * HEDGE_RATIO) / (base_price * CONTRACT_SIZE)))
        
        try:
            order = FuturesOrder(
                contract=SYMBOL,
                size=-short_qty,
                price=str(round(upper_price, 4)),
                tif="gtc"
            )
            api.create_futures_order(SETTLE, order)
        except Exception as e:
            log_debug("‚ùå Ïàè Ï£ºÎ¨∏ Ïã§Ìå®", str(e))
        
        try:
            order = FuturesOrder(
                contract=SYMBOL,
                size=long_qty,
                price=str(round(lower_price, 4)),
                tif="gtc"
            )
            api.create_futures_order(SETTLE, order)
        except Exception as e:
            log_debug("‚ùå Î°± Ï£ºÎ¨∏ Ïã§Ìå®", str(e))
        
        log_debug("üéØ Í∑∏Î¶¨Îìú ÏÉùÏÑ±", 
                 f"Í∏∞Ï§Ä:{base_price:.4f} ÏúÑ:{upper_price:.4f}({short_qty}) ÏïÑÎûò:{lower_price:.4f}({long_qty}) | OBV:{float(obv_macd * 1000):.2f}")
        
    except Exception as e:
        log_debug("‚ùå Í∑∏Î¶¨Îìú ÏÉùÏÑ± Ïã§Ìå®", str(e), exc_info=True)

# =============================================================================
# Ìó§Ïßï Í¥ÄÎ¶¨
# =============================================================================

def place_hedge_order(symbol, side, current_price):
    """Ìó§Ïßï ÏãúÏû•Í∞Ä Ï£ºÎ¨∏ (Ï¶âÏãú Ï≤¥Í≤∞)"""
    try:
        hedge_qty = max(1, int((INITIAL_BALANCE * HEDGE_RATIO) / (current_price * CONTRACT_SIZE)))
        
        if side == "short":
            order_size = -hedge_qty
        else:
            order_size = hedge_qty
        
        order = FuturesOrder(
            contract=symbol,
            size=order_size,
            price="0",
            tif="ioc"
        )
        
        result = api.create_futures_order(SETTLE, order)
        
        log_debug("üìå Ìó§Ïßï Ï£ºÎ¨∏", f"{symbol} {side} {hedge_qty}Í≥ÑÏïΩ ID:{result.id}")
        
        time.sleep(0.5)
        try:
            order_status = api.get_futures_order(SETTLE, result.id)
            if order_status.status == "finished":
                log_debug("‚úÖ Ìó§Ïßï Ï≤¥Í≤∞ ÏôÑÎ£å", f"ID:{result.id}")
            else:
                log_debug("‚ö†Ô∏è Ìó§Ïßï ÎØ∏Ï≤¥Í≤∞", f"ÏÉÅÌÉú:{order_status.status}")
        except:
            pass
        
        return result.id
        
    except Exception as e:
        log_debug("‚ùå Ìó§Ïßï Ï£ºÎ¨∏ Ïã§Ìå®", str(e))
        return None

# =============================================================================
# Ï≤¥Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ
# =============================================================================

def fill_monitor():
    """Ï≤¥Í≤∞ Í∞êÏßÄ (ÏòàÏô∏ Ï≤òÎ¶¨ Í∞ïÌôî + Í∞úÎ≥Ñ Ïø®Îã§Ïö¥)"""
    try:
        update_position_state(SYMBOL, show_log=True)
        
        prev_long_size = Decimal("0")
        prev_short_size = Decimal("0")
        last_long_action_time = 0
        last_short_action_time = 0
        last_heartbeat = time.time()
        
        with position_lock:
            pos = position_state.get(SYMBOL, {})
            prev_long_size = pos.get("long", {}).get("size", Decimal("0"))
            prev_short_size = pos.get("short", {}).get("size", Decimal("0"))
        
        log_debug("üëÄ Ï≤¥Í≤∞ Î™®ÎãàÌÑ∞ ÏãúÏûë", f"Ï¥àÍ∏∞ Î°±:{prev_long_size} Ïàè:{prev_short_size}")
        
        while True:
            try:
                time.sleep(2)
                
                now = time.time()
                if now - last_heartbeat >= 60:
                    with position_lock:
                        pos = position_state.get(SYMBOL, {})
                        current_long = pos.get("long", {}).get("size", Decimal("0"))
                        current_short = pos.get("short", {}).get("size", Decimal("0"))
                    log_debug("üíì Ï≤¥Í≤∞ Î™®ÎãàÌÑ∞ ÏûëÎèô Ï§ë", f"Î°±:{current_long} Ïàè:{current_short}")
                    last_heartbeat = now
                
                update_position_state(SYMBOL)
                
                with position_lock:
                    pos = position_state.get(SYMBOL, {})
                    long_size = pos.get("long", {}).get("size", Decimal("0"))
                    short_size = pos.get("short", {}).get("size", Decimal("0"))
                    long_price = pos.get("long", {}).get("price", Decimal("0"))
                    short_price = pos.get("short", {}).get("price", Decimal("0"))
                    
                    now = time.time()
                    
                    try:
                        ticker = api.list_futures_tickers(SETTLE, contract=SYMBOL)
                        current_price = Decimal(str(ticker[0].last)) if ticker else Decimal("0")
                    except:
                        current_price = Decimal("0")
                    
                    # Î°± Ï≤¥Í≤∞ Í∞êÏßÄ
                    if long_size > prev_long_size and now - last_long_action_time >= 3:
                        try:
                            added_long = long_size - prev_long_size
                            
                            log_debug("üìä Î°± Ï≤¥Í≤∞ Í∞êÏßÄ", f"+{added_long}Í≥ÑÏïΩ @ {long_price:.4f} (Ï¥ù {long_size}Í≥ÑÏïΩ)")
                            
                            record_entry(SYMBOL, "long", long_price, added_long)
                            
                            cancel_grid_orders(SYMBOL)
                            time.sleep(0.5)
                            
                            max_wait = 1.0
                            check_interval = 0.2
                            elapsed = 0
                            
                            while elapsed < max_wait:
                                time.sleep(check_interval)
                                elapsed += check_interval
                                
                                try:
                                    orders = api.list_futures_orders(SETTLE, contract=SYMBOL, status="open")
                                    grid_orders = [o for o in orders if not o.is_reduce_only]
                                    
                                    if not grid_orders:
                                        log_debug("‚úÖ Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÌôïÏù∏", f"{elapsed:.1f}Ï¥à")
                                        break
                                except:
                                    pass
                            else:
                                log_debug("‚ö†Ô∏è Í∑∏Î¶¨Îìú ÎØ∏Ï∑®ÏÜå", "TP ÏÑ§Ï†ï Í≥ÑÏÜç ÏßÑÌñâ")
                            
                            log_debug("üîÑ TP ÏÉàÎ°úÍ≥†Ïπ® (Î°±)", "")
                            refresh_tp_orders(SYMBOL)
                            time.sleep(0.3)
                            
                            if current_price > 0:
                                log_debug("üî® Ïàè Ìó§Ïßï Ï£ºÎ¨∏", f"{current_price:.4f}")
                                place_hedge_order(SYMBOL, "short", current_price)
                                
                                log_debug("‚è≥ Ìó§Ïßï Ï≤¥Í≤∞ ÌôïÏù∏ Ï§ë...", "")
                                hedge_filled = False
                                for retry in range(10):
                                    time.sleep(0.5)
                                    if update_position_state(SYMBOL):
                                        with position_lock:
                                            pos = position_state.get(SYMBOL, {})
                                            current_short = pos.get("short", {}).get("size", Decimal("0"))
                                            
                                            if current_short > prev_short_size:
                                                hedge_filled = True
                                                log_debug("‚úÖ Ìó§Ïßï Ï≤¥Í≤∞ ÌôïÏù∏", f"Ïàè:{current_short}Í≥ÑÏïΩ (Ïû¨ÏãúÎèÑ {retry + 1}/10)")
                                                break
                                
                                if hedge_filled:
                                    time.sleep(1.0)
                                    update_position_state(SYMBOL, show_log=True)
                                    
                                    with position_lock:
                                        pos = position_state.get(SYMBOL, {})
                                        final_short = pos.get("short", {}).get("size", Decimal("0"))
                                        log_debug("üîç ÏµúÏ¢Ö Ïàè Ìè¨ÏßÄÏÖò", f"{final_short}Í≥ÑÏïΩ")
                                else:
                                    log_debug("‚ö†Ô∏è Ìó§Ïßï ÎØ∏Ï≤¥Í≤∞", "TP ÏÑ§Ï†ï Ï£ºÏùò ÌïÑÏöî")
                            
                            success = False
                            for retry in range(5):
                                if update_position_state(SYMBOL):
                                    log_debug("‚úÖ Ìè¨ÏßÄÏÖò Ïû¨Ï°∞Ìöå ÏÑ±Í≥µ", f"Ïû¨ÏãúÎèÑ {retry + 1}/5")
                                    success = True
                                    break
                                time.sleep(0.5)
                            
                            if success:
                                time.sleep(0.5)
                                log_debug("üîÑ Ï†ÑÏ≤¥ TP Ïû¨ÏÑ§Ï†ï", "Î°±+Ïàè")
                                refresh_tp_orders(SYMBOL)
                                
                                time.sleep(1)
                                update_position_state(SYMBOL, show_log=True)
                            
                            with position_lock:
                                pos = position_state.get(SYMBOL, {})
                                prev_long_size = pos.get("long", {}).get("size", Decimal("0"))
                                prev_short_size = pos.get("short", {}).get("size", Decimal("0"))
                                log_debug("‚úÖ Î°± Ï≤¥Í≤∞ Ï≤òÎ¶¨ ÏôÑÎ£å", f"ÏµúÏ¢Ö Î°±:{prev_long_size} Ïàè:{prev_short_size}")
                            
                            last_long_action_time = now
                            
                        except Exception as e:
                            log_debug("‚ùå Î°± Ï≤òÎ¶¨ Ïò§Î•ò", str(e), exc_info=True)
                    
                    # Ïàè Ï≤¥Í≤∞ Í∞êÏßÄ
                    if short_size > prev_short_size and now - last_short_action_time >= 3:
                        try:
                            added_short = short_size - prev_short_size
                            
                            log_debug("üìä Ïàè Ï≤¥Í≤∞ Í∞êÏßÄ", f"+{added_short}Í≥ÑÏïΩ @ {short_price:.4f} (Ï¥ù {short_size}Í≥ÑÏïΩ)")
                            
                            record_entry(SYMBOL, "short", short_price, added_short)
                            
                            cancel_grid_orders(SYMBOL)
                            time.sleep(0.5)
                            
                            max_wait = 1.0
                            check_interval = 0.2
                            elapsed = 0
                            
                            while elapsed < max_wait:
                                time.sleep(check_interval)
                                elapsed += check_interval
                                
                                try:
                                    orders = api.list_futures_orders(SETTLE, contract=SYMBOL, status="open")
                                    grid_orders = [o for o in orders if not o.is_reduce_only]
                                    
                                    if not grid_orders:
                                        log_debug("‚úÖ Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÌôïÏù∏", f"{elapsed:.1f}Ï¥à")
                                        break
                                except:
                                    pass
                            else:
                                log_debug("‚ö†Ô∏è Í∑∏Î¶¨Îìú ÎØ∏Ï∑®ÏÜå", "TP ÏÑ§Ï†ï Í≥ÑÏÜç ÏßÑÌñâ")
                            
                            log_debug("üîÑ TP ÏÉàÎ°úÍ≥†Ïπ® (Ïàè)", "")
                            refresh_tp_orders(SYMBOL)
                            time.sleep(0.3)
                            
                            if current_price > 0:
                                log_debug("üî® Î°± Ìó§Ïßï Ï£ºÎ¨∏", f"{current_price:.4f}")
                                place_hedge_order(SYMBOL, "long", current_price)
                                
                                log_debug("‚è≥ Ìó§Ïßï Ï≤¥Í≤∞ ÌôïÏù∏ Ï§ë...", "")
                                hedge_filled = False
                                for retry in range(10):
                                    time.sleep(0.5)
                                    if update_position_state(SYMBOL):
                                        with position_lock:
                                            pos = position_state.get(SYMBOL, {})
                                            current_long = pos.get("long", {}).get("size", Decimal("0"))
                                            
                                            if current_long > prev_long_size:
                                                hedge_filled = True
                                                log_debug("‚úÖ Ìó§Ïßï Ï≤¥Í≤∞ ÌôïÏù∏", f"Î°±:{current_long}Í≥ÑÏïΩ (Ïû¨ÏãúÎèÑ {retry + 1}/10)")
                                                break
                                
                                if hedge_filled:
                                    time.sleep(1.0)
                                    update_position_state(SYMBOL, show_log=True)
                                    
                                    with position_lock:
                                        pos = position_state.get(SYMBOL, {})
                                        final_long = pos.get("long", {}).get("size", Decimal("0"))
                                        log_debug("üîç ÏµúÏ¢Ö Î°± Ìè¨ÏßÄÏÖò", f"{final_long}Í≥ÑÏïΩ")
                                else:
                                    log_debug("‚ö†Ô∏è Ìó§Ïßï ÎØ∏Ï≤¥Í≤∞", "TP ÏÑ§Ï†ï Ï£ºÏùò ÌïÑÏöî")
                            
                            success = False
                            for retry in range(5):
                                if update_position_state(SYMBOL):
                                    log_debug("‚úÖ Ìè¨ÏßÄÏÖò Ïû¨Ï°∞Ìöå ÏÑ±Í≥µ", f"Ïû¨ÏãúÎèÑ {retry + 1}/5")
                                    success = True
                                    break
                                time.sleep(0.5)
                            
                            if success:
                                time.sleep(0.5)
                                log_debug("üîÑ Ï†ÑÏ≤¥ TP Ïû¨ÏÑ§Ï†ï", "Î°±+Ïàè")
                                refresh_tp_orders(SYMBOL)
                                
                                time.sleep(1)
                                update_position_state(SYMBOL, show_log=True)
                            
                            with position_lock:
                                pos = position_state.get(SYMBOL, {})
                                prev_long_size = pos.get("long", {}).get("size", Decimal("0"))
                                prev_short_size = pos.get("short", {}).get("size", Decimal("0"))
                                log_debug("‚úÖ Ïàè Ï≤¥Í≤∞ Ï≤òÎ¶¨ ÏôÑÎ£å", f"ÏµúÏ¢Ö Î°±:{prev_long_size} Ïàè:{prev_short_size}")
                            
                            last_short_action_time = now
                            
                        except Exception as e:
                            log_debug("‚ùå Ïàè Ï≤òÎ¶¨ Ïò§Î•ò", str(e), exc_info=True)
                
            except Exception as e:
                log_debug("‚ùå Ï≤¥Í≤∞ Î™®ÎãàÌÑ∞ Î£®ÌîÑ Ïò§Î•ò", str(e), exc_info=True)
                time.sleep(5)
                continue
                
    except Exception as e:
        log_debug("‚ùå Ï≤¥Í≤∞ Î™®ÎãàÌÑ∞ Ï¥àÍ∏∞Ìôî Ïã§Ìå®", str(e), exc_info=True)

# =============================================================================
# TP Ï≤¥Í≤∞ Î™®ÎãàÌÑ∞ÎßÅ
# =============================================================================

def tp_monitor():
    """TP Ï≤¥Í≤∞ Í∞êÏßÄ Î∞è Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ± (Î™®Îì† Ï†ÑÏ≤¥ Ï≤≠ÏÇ∞ Ïãú Ïû¨ÏÉùÏÑ±!)"""
    prev_long_size = None
    prev_short_size = None
    
    while True:
        time.sleep(3)
        
        try:
            update_position_state(SYMBOL)
            
            with position_lock:
                pos = position_state.get(SYMBOL, {})
                long_size = pos.get("long", {}).get("size", Decimal("0"))
                short_size = pos.get("short", {}).get("size", Decimal("0"))
                
                if prev_long_size is None:
                    prev_long_size = long_size
                    prev_short_size = short_size
                    log_debug("üëÄ TP Î™®ÎãàÌÑ∞ ÏãúÏûë", f"Ï¥àÍ∏∞ Î°±:{long_size} Ïàè:{short_size}")
                    continue
                
                # ‚≠ê‚≠ê‚≠ê Î°± Ìè¨ÏßÄÏÖòÏù¥ 0Ïù¥ ÎêòÏóàÏùÑ Îïå (Í∞úÎ≥Ñ TPÎèÑ Ïû¨ÏÉùÏÑ±!)
                if long_size == 0 and prev_long_size > 0:
                    prev_long_size = long_size
                    
                    long_type = tp_type.get(SYMBOL, {}).get("long", "average")
                    
                    if long_type == "average":
                        log_debug("‚úÖ Î°± ÌèâÎã® TP Ï≤≠ÏÇ∞", "Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ±!")
                    else:
                        log_debug("‚úÖ Î°± Í∞úÎ≥Ñ TP Ï†ÑÏ≤¥ Ï≤≠ÏÇ∞", "Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ±!")
                    
                    if SYMBOL in entry_history:
                        entry_history[SYMBOL]["long"] = []
                    if SYMBOL in tp_type:
                        tp_type[SYMBOL]["long"] = "average"
                    
                    cancel_grid_orders(SYMBOL)
                    time.sleep(0.5)
                    
                    max_wait = 2.0
                    check_interval = 0.2
                    elapsed = 0
                    
                    while elapsed < max_wait:
                        time.sleep(check_interval)
                        elapsed += check_interval
                        
                        orders = api.list_futures_orders(SETTLE, contract=SYMBOL, status="open")
                        grid_orders = [o for o in orders if not o.is_reduce_only]
                        
                        if not grid_orders:
                            log_debug("‚úÖ Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÏôÑÎ£å", f"{elapsed:.1f}Ï¥à")
                            break
                    else:
                        log_debug("‚ö†Ô∏è Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÎØ∏ÏôÑÎ£å", "Í∞ïÏ†ú Ïû¨ÏÉùÏÑ±")
                    
                    ticker = api.list_futures_tickers(SETTLE, contract=SYMBOL)
                    if ticker:
                        current_price = Decimal(str(ticker[0].last))
                        initialize_grid(current_price, skip_check=True)
                        
                        time.sleep(1.5)
                        update_position_state(SYMBOL)
                        refresh_tp_orders(SYMBOL)
                        
                        time.sleep(1.0)
                        update_position_state(SYMBOL, show_log=True)
                        refresh_tp_orders(SYMBOL)

                        with position_lock:
                            pos = position_state.get(SYMBOL, {})
                            final_long = pos.get("long", {}).get("size", Decimal("0"))
                            final_short = pos.get("short", {}).get("size", Decimal("0"))
    
                            if final_long > 0 or final_short > 0:
                                log_debug("‚úÖ Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ± ÏôÑÎ£å", f"Î°±:{final_long} Ïàè:{final_short}")
                            else:
                                log_debug("‚ö†Ô∏è Ìè¨ÏßÄÏÖò ÏóÜÏùå", "ÎåÄÍ∏∞ ÏÉÅÌÉú")
                
                # ‚≠ê‚≠ê‚≠ê Ïàè Ìè¨ÏßÄÏÖòÏù¥ 0Ïù¥ ÎêòÏóàÏùÑ Îïå (Í∞úÎ≥Ñ TPÎèÑ Ïû¨ÏÉùÏÑ±!)
                elif short_size == 0 and prev_short_size > 0:
                    prev_short_size = short_size
                    
                    short_type = tp_type.get(SYMBOL, {}).get("short", "average")
                    
                    if short_type == "average":
                        log_debug("‚úÖ Ïàè ÌèâÎã® TP Ï≤≠ÏÇ∞", "Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ±!")
                    else:
                        log_debug("‚úÖ Ïàè Í∞úÎ≥Ñ TP Ï†ÑÏ≤¥ Ï≤≠ÏÇ∞", "Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ±!")
                    
                    if SYMBOL in entry_history:
                        entry_history[SYMBOL]["short"] = []
                    if SYMBOL in tp_type:
                        tp_type[SYMBOL]["short"] = "average"
                    
                    cancel_grid_orders(SYMBOL)
                    time.sleep(0.5)
                    
                    max_wait = 2.0
                    check_interval = 0.2
                    elapsed = 0
                    
                    while elapsed < max_wait:
                        time.sleep(check_interval)
                        elapsed += check_interval
                        
                        orders = api.list_futures_orders(SETTLE, contract=SYMBOL, status="open")
                        grid_orders = [o for o in orders if not o.is_reduce_only]
                        
                        if not grid_orders:
                            log_debug("‚úÖ Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÏôÑÎ£å", f"{elapsed:.1f}Ï¥à")
                            break
                    else:
                        log_debug("‚ö†Ô∏è Í∑∏Î¶¨Îìú Ï∑®ÏÜå ÎØ∏ÏôÑÎ£å", "Í∞ïÏ†ú Ïû¨ÏÉùÏÑ±")
                    
                    ticker = api.list_futures_tickers(SETTLE, contract=SYMBOL)
                    if ticker:
                        current_price = Decimal(str(ticker[0].last))
                        initialize_grid(current_price, skip_check=True)
                        
                        time.sleep(1.5)
                        update_position_state(SYMBOL)
                        refresh_tp_orders(SYMBOL)
                        
                        time.sleep(1.0)
                        update_position_state(SYMBOL, show_log=True)
                        refresh_tp_orders(SYMBOL)

                        with position_lock:
                            pos = position_state.get(SYMBOL, {})
                            final_long = pos.get("long", {}).get("size", Decimal("0"))
                            final_short = pos.get("short", {}).get("size", Decimal("0"))
    
                            if final_long > 0 or final_short > 0:
                                log_debug("‚úÖ Í∑∏Î¶¨Îìú Ïû¨ÏÉùÏÑ± ÏôÑÎ£å", f"Î°±:{final_long} Ïàè:{final_short}")
                            else:
                                log_debug("‚ö†Ô∏è Ìè¨ÏßÄÏÖò ÏóÜÏùå", "ÎåÄÍ∏∞ ÏÉÅÌÉú")
                
                else:
                    prev_long_size = long_size
                    prev_short_size = short_size
                
        except Exception as e:
            log_debug("‚ùå TP Î™®ÎãàÌÑ∞ Ïò§Î•ò", str(e), exc_info=True)

# =============================================================================
# WebSocket Í∞ÄÍ≤© Î™®ÎãàÌÑ∞ÎßÅ
# =============================================================================

async def price_monitor():
    """Í∞ÄÍ≤© Î™®ÎãàÌÑ∞ÎßÅ (WebSocket)"""
    uri = "wss://fx-ws.gateio.ws/v4/ws/usdt"
    retry_count = 0
    
    while True:
        try:
            async with websockets.connect(uri) as ws:
                subscribe_msg = {
                    "time": int(time.time()),
                    "channel": "futures.tickers",
                    "event": "subscribe",
                    "payload": [SYMBOL]
                }
                await ws.send(json.dumps(subscribe_msg))
                
                if retry_count > 0:
                    log_debug("üîó WebSocket Ïû¨Ïó∞Í≤∞ ÏÑ±Í≥µ", f"{SYMBOL} (Ïû¨ÏãúÎèÑ {retry_count}Ìöå ÌõÑ)")
                else:
                    log_debug("üîó WebSocket Ïó∞Í≤∞", SYMBOL)
                
                retry_count = 0
                
                while True:
                    msg = await ws.recv()
                    data = json.loads(msg)
                    
                    if data.get("event") == "update" and data.get("channel") == "futures.tickers":
                        result = data.get("result")
                        if result and isinstance(result, dict):
                            price = Decimal(str(result.get("last", "0")))
                            if price > 0:
                                latest_prices[SYMBOL] = price
                    
        except Exception as e:
            retry_count += 1
            if retry_count % 10 == 1:
                log_debug("‚ùå WebSocket Ïò§Î•ò", f"Ïû¨ÏãúÎèÑ {retry_count}Ìöå")
            await asyncio.sleep(5)

# =============================================================================
# Ïõπ ÏÑúÎ≤Ñ
# =============================================================================

@app.route("/ping", methods=["GET", "POST"])
def ping():
    """Health Check"""
    return jsonify({"status": "ok", "time": time.time()})

# =============================================================================
# Î©îÏù∏
# =============================================================================

if __name__ == "__main__":
    log_debug("üöÄ ÏÑúÎ≤Ñ ÏãúÏûë", "v17.0-FINAL")
    
    INITIAL_BALANCE = Decimal(str(get_available_balance(show_log=True)))
    log_debug("üí∞ Ï¥àÍ∏∞ ÏûîÍ≥†", f"{INITIAL_BALANCE:.2f} USDT")
    log_debug("üéØ ÏûÑÍ≥ÑÍ∞í", f"{float(INITIAL_BALANCE * THRESHOLD_RATIO):.2f} USDT ({int(THRESHOLD_RATIO)}Î∞∞)")
    log_debug("üõ°Ô∏è Ìó§Ïßï Í∏∞Ï§Ä", f"{float(INITIAL_BALANCE * HEDGE_RATIO * Decimal('1.5')):.2f} USDT (0.45Î∞∞)")
    
    entry_history[SYMBOL] = {"long": [], "short": []}
    tp_orders[SYMBOL] = {"long": [], "short": []}
    tp_type[SYMBOL] = {"long": "average", "short": "average"}
    
    obv_macd_val = calculate_obv_macd(SYMBOL)
    log_debug("üìä Shadow OBV MACD", f"{SYMBOL}: {float(obv_macd_val * 1000):.2f}")
    
    update_position_state(SYMBOL, show_log=True)
    with position_lock:
        pos = position_state.get(SYMBOL, {})
        long_size = pos.get("long", {}).get("size", Decimal("0"))
        short_size = pos.get("short", {}).get("size", Decimal("0"))
        
        if long_size > 0 or short_size > 0:
            log_debug("‚ö†Ô∏è Í∏∞Ï°¥ Ìè¨ÏßÄÏÖò Í∞êÏßÄ", f"Î°±:{long_size} Ïàè:{short_size}")
            
            log_debug("üóëÔ∏è Í∏∞Ï°¥ Í∑∏Î¶¨Îìú Ï∑®ÏÜå", "ÏãúÏûë...")
            cancel_grid_orders(SYMBOL)
            time.sleep(1)
            
            log_debug("üîß Í∏∞Ï°¥ Ìè¨ÏßÄÏÖò TP ÏÑ§Ï†ï", "ÏãúÏûë...")
            emergency_tp_fix(SYMBOL)
            time.sleep(1)
            
            log_debug("üéØ ÏÉà Í∑∏Î¶¨Îìú ÏÉùÏÑ±", "ÏãúÏûë...")
            initialize_grid(skip_check=True)
        else:
            log_debug("‚úÖ Ìè¨ÏßÄÏÖò ÏóÜÏùå", "Ï¥àÍ∏∞ Í∑∏Î¶¨Îìú ÏÉùÏÑ±...")
            initialize_grid()
    
    threading.Thread(target=fill_monitor, daemon=True).start()
    threading.Thread(target=tp_monitor, daemon=True).start()
    threading.Thread(target=lambda: asyncio.run(price_monitor()), daemon=True).start()
    
    port = int(os.environ.get("PORT", 8080))
    log_debug("üåê Ïõπ ÏÑúÎ≤Ñ ÏãúÏûë", f"0.0.0.0:{port}")
    app.run(host="0.0.0.0", port=port, debug=False, threaded=True)
