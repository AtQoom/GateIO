#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gate.io ÏûêÎèôÎß§Îß§ ÏÑúÎ≤Ñ v6.25 - TP ÏãúÏä§ÌÖú Í∞ÑÏÜåÌôî
Í∞ÑÎã®Ìïú WebSocket Î∞±ÏóÖ TPÎßå ÏÇ¨Ïö©, Î≥µÏû°Ìïú API TP ÏãúÏä§ÌÖú Ï†úÍ±∞
"""
import os
import json
import time
import asyncio
import threading
import websockets
import logging
import sys
from decimal import Decimal, ROUND_DOWN
from datetime import datetime
from flask import Flask, request, jsonify
from gate_api import ApiClient, Configuration, FuturesApi, FuturesOrder, UnifiedApi
from gate_api import exceptions as gate_api_exceptions
import queue
import pytz
import urllib.parse 

# ========
# 1. Î°úÍπÖ ÏÑ§Ï†ï
# ========
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(levelname)s] %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)
logging.getLogger('werkzeug').setLevel(logging.ERROR)

def log_debug(tag, msg, exc_info=False):
    logger.info(f"[{tag}] {msg}")
    if exc_info:
        logger.exception("")

# ========
# 2. Flask Ïï± Î∞è API ÏÑ§Ï†ï
# ========
try:
    app = Flask(__name__)
    logger.info("Flask Ïï± Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
except Exception as e:
    logger.error(f"Flask Ïï± Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
    try:
        app = Flask("gate_trading_server")
        logger.info("ÎåÄÏïà Flask Ïï± Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
    except Exception as e2:
        logger.critical(f"Flask Ïï± Ï¥àÍ∏∞Ìôî ÏôÑÏ†Ñ Ïã§Ìå®: {e2}")
        sys.exit(1)

API_KEY = os.environ.get("API_KEY", "")
API_SECRET = os.environ.get("API_SECRET", "")
SETTLE = "usdt"

if not API_KEY or not API_SECRET:
    logger.critical("API_KEY ÎòêÎäî API_SECRETÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    sys.exit(1)

try:
    config = Configuration(key=API_KEY, secret=API_SECRET)
    client = ApiClient(config)
    api = FuturesApi(client)
    unified_api = UnifiedApi(client)
    logger.info("Gate.io API Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
except Exception as e:
    logger.critical(f"Gate.io API Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
    sys.exit(1)

# ========
# 3. ÏÉÅÏàò Î∞è ÏÑ§Ï†ï
# ========
COOLDOWN_SECONDS = 14
PRICE_DEVIATION_LIMIT_PCT = Decimal("0.0005")
MAX_SLIPPAGE_TICKS = 10
KST = pytz.timezone('Asia/Seoul')

SYMBOL_MAPPING = {
    "BTCUSDT": "BTC_USDT", "BTCUSDT.P": "BTC_USDT", "BTCUSDTPERP": "BTC_USDT", "BTC_USDT": "BTC_USDT", "BTC": "BTC_USDT",
    "ETHUSDT": "ETH_USDT", "ETHUSDT.P": "ETH_USDT", "ETHUSDTPERP": "ETH_USDT", "ETH_USDT": "ETH_USDT", "ETH": "ETH_USDT",
    "SOLUSDT": "SOL_USDT", "SOLUSDT.P": "SOL_USDT", "SOLUSDTPERP": "SOL_USDT", "SOL_USDT": "SOL_USDT", "SOL": "SOL_USDT",
    "ADAUSDT": "ADA_USDT", "ADAUSDT.P": "ADA_USDT", "ADAUSDTPERP": "ADA_USDT", "ADA_USDT": "ADA_USDT", "ADA": "ADA_USDT",
    "SUIUSDT": "SUI_USDT", "SUIUSDT.P": "SUI_USDT", "SUIUSDTPERP": "SUI_USDT", "SUI_USDT": "SUI_USDT", "SUI": "SUI_USDT",
    "LINKUSDT": "LINK_USDT", "LINKUSDT.P": "LINK_USDT", "LINKUSDTPERP": "LINK_USDT", "LINK_USDT": "LINK_USDT", "LINK": "LINK_USDT",
    "PEPEUSDT": "PEPE_USDT", "PEPEUSDT.P": "PEPE_USDT", "PEPEUSDTPERP": "PEPE_USDT", "PEPE_USDT": "PEPE_USDT", "PEPE": "PEPE_USDT",
    "XRPUSDT": "XRP_USDT", "XRPUSDT.P": "XRP_USDT", "XRPUSDTPERP": "XRP_USDT", "XRP_USDT": "XRP_USDT", "XRP": "XRP_USDT",
    "DOGEUSDT": "DOGE_USDT", "DOGEUSDT.P": "DOGE_USDT", "DOGEUSDTPERP": "DOGE_USDT", "DOGE_USDT": "DOGE_USDT", "DOGE": "DOGE_USDT",
    "ONDOUSDT": "ONDO_USDT", "ONDOUSDT.P": "ONDO_USDT", "ONDOUSDTPERP": "ONDO_USDT", "ONDO_USDT": "ONDO_USDT", "ONDO": "ONDO_USDT",
}

SYMBOL_CONFIG = {
    "BTC_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("0.0001"), "min_notional": Decimal("5"), "tp_mult": 0.55, "sl_mult": 0.55, "tick_size": Decimal("0.1")},
    "ETH_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("0.01"), "min_notional": Decimal("5"), "tp_mult": 0.65, "sl_mult": 0.65, "tick_size": Decimal("0.01")},
    "SOL_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 0.8, "sl_mult": 0.8, "tick_size": Decimal("0.001")},
    "ADA_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.0001")},
    "SUI_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.001")},
    "LINK_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.001")},
    "PEPE_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10000000"), "min_notional": Decimal("5"), "tp_mult": 1.2, "sl_mult": 1.2, "tick_size": Decimal("0.00000001"), "price_multiplier": Decimal("100000000.0")},
    "XRP_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.0001")},
    "DOGE_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10"), "min_notional": Decimal("5"), "tp_mult": 1.2, "sl_mult": 1.2, "tick_size": Decimal("0.00001")},
    "ONDO_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.0001")}
}

# ========
# 4. üî• Í∞ÑÏÜåÌôîÎêú ÏñëÎ∞©Ìñ• ÏÉÅÌÉú Í¥ÄÎ¶¨
# ========
position_state = {}
position_lock = threading.RLock()
account_cache = {"time": 0, "data": None}
recent_signals = {}
signal_lock = threading.RLock()
tpsl_storage = {}
tpsl_lock = threading.RLock()
task_q = queue.Queue(maxsize=100)
WORKER_COUNT = min(6, max(2, os.cpu_count() * 2))

def get_default_pos_side_state():
    """Í∞ÑÏÜåÌôîÎêú Í∏∞Î≥∏ ÏÉÅÌÉú"""
    return {
        "price": None, "size": Decimal("0"), "value": Decimal("0"), "entry_count": 0,
        "normal_entry_count": 0, "premium_entry_count": 0, "rescue_entry_count": 0,
        "entry_time": None, 'last_entry_ratio': Decimal("0")
    }

def initialize_states():
    with position_lock, tpsl_lock:
        for sym in SYMBOL_CONFIG:
            if sym not in position_state:
                position_state[sym] = {"long": get_default_pos_side_state(), "short": get_default_pos_side_state()}
            if sym not in tpsl_storage:
                tpsl_storage[sym] = {"long": {}, "short": {}}

# ========
# 5. ÌïµÏã¨ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
# ========
def _get_api_response(api_call, *args, **kwargs):
    max_retries = 3
    for attempt in range(max_retries):
        try:
            return api_call(*args, **kwargs)
        except Exception as e:
            if isinstance(e, gate_api_exceptions.ApiException):
                error_msg = f"API Error {e.status}: {e.body if hasattr(e, 'body') else e.reason}"
            else:
                error_msg = str(e)
            
            if attempt < max_retries - 1:
                log_debug("‚ö†Ô∏è API Ìò∏Ï∂ú Ïû¨ÏãúÎèÑ", f"ÏãúÎèÑ {attempt+1}/{max_retries}: {error_msg}, Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ")
                time.sleep(1)
            else:
                log_debug("‚ùå API Ìò∏Ï∂ú ÏµúÏ¢Ö Ïã§Ìå®", error_msg, exc_info=True)
    return None

def normalize_symbol(raw_symbol):
    """üî• Í∞ïÌôîÎêú Ïã¨Î≥º Ï†ïÍ∑úÌôî (SOL Î¨∏Ï†ú Ìï¥Í≤∞)"""
    if not raw_symbol:
        return None
    
    symbol = str(raw_symbol).upper().strip()
    
    # Í∏∞Î≥∏ Îß§Ìïë Î®ºÏ†Ä ÏãúÎèÑ
    normalized = SYMBOL_MAPPING.get(symbol)
    if normalized:
        return normalized
        
    # SOL Í¥ÄÎ†® Ï∂îÍ∞Ä Ï≤¥ÌÅ¨
    if "SOL" in symbol:
        return "SOL_USDT"
    
    # Îã§Î•∏ Î≥ÄÌòïÎì§ÎèÑ Ï≤¥ÌÅ¨
    clean_symbol = symbol.replace('.P', '').replace('PERP', '').replace('USDT', '')
    for key, value in SYMBOL_MAPPING.items():
        if clean_symbol in key:
            return value
    
    log_debug("‚ö†Ô∏è Ïã¨Î≥º Ï†ïÍ∑úÌôî Ïã§Ìå®", f"'{raw_symbol}' ‚Üí Îß§ÌïëÎêòÏßÄ ÏïäÏùÄ Ïã¨Î≥º")
    return symbol

def get_total_collateral(force=False):
    now = time.time()
    if not force and account_cache["time"] > now - 30 and account_cache["data"]:
        return account_cache["data"]
    
    acc = _get_api_response(api.list_futures_accounts, SETTLE)
    equity = Decimal(str(getattr(acc, 'total', '0'))) if acc else Decimal("0")
    account_cache.update({"time": now, "data": equity})
    return equity

def get_price(symbol):
    ticker = _get_api_response(api.list_futures_tickers, SETTLE, contract=symbol)
    if ticker and isinstance(ticker, list) and len(ticker) > 0:
        return Decimal(str(ticker[0].last))
    return Decimal("0")

# ========
# 6. ÌååÏù∏Ïä§ÌÅ¨Î¶ΩÌä∏ Ïó∞Îèô Ìï®Ïàò
# ========
def get_signal_type_multiplier(signal_type):
    if "premium" in signal_type: return Decimal("2.0")
    if "rescue" in signal_type: return Decimal("1.5")
    return Decimal("1.0")

def get_entry_weight_from_score(score):
    try:
        score = Decimal(str(score))
        if score <= 10: return Decimal("0.25")
        elif score <= 30: return Decimal("0.35")
        elif score <= 50: return Decimal("0.50")
        elif score <= 70: return Decimal("0.65")
        elif score <= 90: return Decimal("0.80")
        else: return Decimal("1.00")
    except Exception: return Decimal("0.25")

def get_ratio_by_index(idx):
    ratios = [Decimal("5.0"), Decimal("10.0"), Decimal("25.0"), Decimal("60.0"), Decimal("200.0")]
    return ratios[min(idx, len(ratios) - 1)]

def get_tp_by_index(idx):
    tps = [Decimal("0.005"), Decimal("0.004"), Decimal("0.0035"), Decimal("0.003"), Decimal("0.002")]
    return tps[min(idx, len(tps) - 1)]

def get_sl_by_index(idx):
    sls = [Decimal("0.04"), Decimal("0.038"), Decimal("0.035"), Decimal("0.033"), Decimal("0.03")]
    return sls[min(idx, len(sls) - 1)]

# ========
# 7. üî• ÌèâÎã®Í∞Ä Îß§Ïπ≠ ÏàòÎüâ Í≥ÑÏÇ∞ Ìï®Ïàò Ï∂îÍ∞Ä
# ========
def calculate_qty_to_match_avg_price(symbol, tv_expected_avg):
    """TradingView ÏòàÏÉÅ ÌèâÎã®Í∞ÄÏóê ÎßûÏ∂îÎäî ÏàòÎüâ Í≥ÑÏÇ∞"""
    try:
        # ÌòÑÏû¨ ÏÑúÎ≤Ñ Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥
        pos_side_state = position_state.get(symbol, {})
        side = "long" if pos_side_state.get("long", {}).get("size", Decimal(0)) > 0 else "short"
        current_pos = pos_side_state.get(side, {})
        
        current_qty = current_pos.get('size', Decimal(0))
        current_avg = current_pos.get('price', Decimal(0))
        
        # ÌòÑÏû¨ ÏãúÏû•Í∞Ä
        current_price = get_price(symbol)
        
        if current_qty == 0 or current_avg == 0:
            # Ï≤´ ÏßÑÏûÖÏù¥Î©¥ Ï†ïÏÉÅ Í≥ÑÏÇ∞
            return None
        
        # TV ÏòàÏÉÅ ÌèâÎã®Í∞ÄÏóê ÎßûÎäî ÏàòÎüâ Ïó≠Í≥ÑÏÇ∞
        target_avg = Decimal(str(tv_expected_avg))
        
        if current_price == target_avg:
            return Decimal(0)  # Ï∂îÍ∞Ä ÏßÑÏûÖ Î∂àÌïÑÏöî
        
        # ÏàòÎüâ Ïó≠Í≥ÑÏÇ∞ Í≥µÏãù
        additional_qty = (current_avg - target_avg) * current_qty / (target_avg - current_price)
        
        # ÏùåÏàòÎ©¥ Î∂àÍ∞ÄÎä•
        if additional_qty <= 0:
            return None
        
        # ÏµúÏÜåÏàòÎüâ, Í≥ÑÏïΩÎã®ÏúÑ Ï°∞Ï†ï
        cfg = SYMBOL_CONFIG[symbol]
        final_qty = max(additional_qty, cfg["min_qty"])
        
        # ÏµúÏÜå Î™ÖÎ™©Í∞ÄÏπò ÌôïÏù∏
        notional = final_qty * current_price * cfg["contract_size"]
        if notional < cfg["min_notional"]:
            min_qty_for_notional = cfg["min_notional"] / (current_price * cfg["contract_size"])
            final_qty = max(final_qty, min_qty_for_notional)
        
        log_debug(f"üìä ÌèâÎã®Í∞Ä Îß§Ïπ≠ ÏàòÎüâ Í≥ÑÏÇ∞ ({symbol})", 
                  f"Î™©ÌëúÌèâÎã®: {target_avg:.8f}, Í≥ÑÏÇ∞ÏàòÎüâ: {final_qty}")
        
        return final_qty
        
    except Exception as e:
        log_debug(f"‚ùå ÌèâÎã®Í∞Ä Îß§Ïπ≠ Í≥ÑÏÇ∞ Ïò§Î•ò ({symbol})", str(e))
        return None

# ========
# 8. ÏñëÎ∞©Ìñ• TP/SL Í¥ÄÎ¶¨
# ========
def store_tp_sl(symbol, side, tp, sl, slippage_pct, entry_number):
    with tpsl_lock: 
        tpsl_storage.setdefault(symbol, {"long": {}, "short": {}}).setdefault(side, {})[entry_number] = {
            "tp": tp, "sl": sl, "entry_slippage_pct": slippage_pct, "entry_time": time.time()
        }

def get_tp_sl(symbol, side, entry_number=None):
    with tpsl_lock:
        side_storage = tpsl_storage.get(symbol, {}).get(side, {})
        if side_storage:
            if entry_number and entry_number in side_storage:
                data = side_storage[entry_number]
                return data["tp"], data["sl"], data["entry_slippage_pct"], data["entry_time"]
            elif side_storage:
                data = side_storage[max(side_storage.keys())]
                return data["tp"], data["sl"], data["entry_slippage_pct"], data["entry_time"]
    
    cfg = SYMBOL_CONFIG.get(symbol, {"tp_mult": 1.0, "sl_mult": 1.0})
    return (Decimal("0.005") * Decimal(str(cfg["tp_mult"])), 
            Decimal("0.04") * Decimal(str(cfg["sl_mult"])), 
            Decimal("0"), 
            time.time())

# ========
# 9. Ï§ëÎ≥µ Ïã†Ìò∏ Ï≤¥ÌÅ¨
# ========
def is_duplicate(data):
    with signal_lock:
        now = time.time()
        symbol = data.get('symbol')
        side = data.get('side')
        
        if not symbol or not side:
            return False
            
        symbol_id = f"{symbol}_{side}"
        
        last_signal = recent_signals.get(symbol_id)
        if last_signal and (now - last_signal.get("last_processed_time", 0) < COOLDOWN_SECONDS):
            return True
        
        recent_signals[symbol_id] = {"last_processed_time": now}
        recent_signals.update({k: v for k, v in recent_signals.items() if now - v.get("last_processed_time", 0) < 300})
        
        return False

# ========
# 10. ÏàòÎüâ Í≥ÑÏÇ∞
# ========
def calculate_position_size(symbol, signal_type, entry_score=50, current_signal_count=0):
    cfg = SYMBOL_CONFIG[symbol]
    equity = get_total_collateral()
    price = get_price(symbol)
    if equity <= 0 or price <= 0:
        return Decimal("0")
    
    base_ratio = get_ratio_by_index(current_signal_count)
    signal_multiplier = get_signal_type_multiplier(signal_type)
    score_weight = get_entry_weight_from_score(entry_score)
    
    final_position_ratio = base_ratio * signal_multiplier * score_weight
    contract_value = price * cfg["contract_size"]
    
    if contract_value <= 0:
        return Decimal("0")
    
    base_qty = (equity * final_position_ratio / Decimal("100") / contract_value).quantize(Decimal('1'), rounding=ROUND_DOWN)
    qty_with_min = max(base_qty, cfg["min_qty"])
    
    if qty_with_min * contract_value < cfg["min_notional"]:
        final_qty = (cfg["min_notional"] / contract_value).quantize(Decimal('1'), rounding=ROUND_DOWN) + Decimal("1")
    else:
        final_qty = qty_with_min
        
    return final_qty

# ========
# 11. ÏñëÎ∞©Ìñ• Ìè¨ÏßÄÏÖò ÏÉÅÌÉú Í¥ÄÎ¶¨
# ========
def update_all_position_states():
    with position_lock:
        all_positions_from_api = _get_api_response(api.list_positions, SETTLE)
        if all_positions_from_api is None:
            log_debug("‚ùå Ìè¨ÏßÄÏÖò ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®", "API Ìò∏Ï∂ú Ïã§Ìå®")
            return
            
        active_positions_set = set()
        for pos_info in all_positions_from_api:
            raw_symbol = pos_info.contract
            api_side = pos_info.mode
            if api_side == 'dual_long':
                side = 'long'
            elif api_side == 'dual_short':
                side = 'short'
            else:
                continue
            
            # üî• ÏàòÏ†ï: Í∞ïÌôîÎêú normalize_symbol Ìï®Ïàò ÏÇ¨Ïö©
            symbol = normalize_symbol(raw_symbol)
            if not symbol:
                log_debug(f"‚ö†Ô∏è Ïïå Ïàò ÏóÜÎäî Ïã¨Î≥º", f"ÏõêÎ≥∏: {raw_symbol}, Ï†ïÍ∑úÌôî Ïã§Ìå®")
                continue
                
            # üî• ÏàòÏ†ï: Ï†ïÍ∑úÌôîÎêú Ïã¨Î≥ºÎ°ú SYMBOL_CONFIG ÌôïÏù∏
            if symbol not in SYMBOL_CONFIG:
                log_debug(f"‚ö†Ô∏è ÎØ∏ÏßÄÏõê Ïã¨Î≥º", f"ÏõêÎ≥∏: {raw_symbol}, Ï†ïÍ∑úÌôî: {symbol}")
                continue
                
            if symbol not in position_state:
                initialize_states()
            
            current_side_state = position_state[symbol][side]
            current_side_state["price"] = Decimal(str(pos_info.entry_price))
            current_side_state["size"] = Decimal(str(pos_info.size))
            current_side_state["value"] = Decimal(str(pos_info.size)) * Decimal(str(pos_info.mark_price)) * SYMBOL_CONFIG[symbol]["contract_size"]
            
            # ÏàòÎèô Ìè¨ÏßÄÏÖò Í∞êÏßÄ
            if current_side_state["entry_count"] == 0 and current_side_state["size"] > 0:
                log_debug("üîÑ ÏàòÎèô Ìè¨ÏßÄÏÖò Í∞êÏßÄ", f"{symbol} {side.upper()} Ìè¨ÏßÄÏÖò")
                current_side_state["entry_count"] = 1
                current_side_state["entry_time"] = time.time()
                
            active_positions_set.add((symbol, side))
            
        # Ïú†Î†π Ìè¨ÏßÄÏÖò Ï†ïÎ¶¨
        for symbol, sides in position_state.items():
            for side in ["long", "short"]:
                if (symbol, side) not in active_positions_set and sides[side]["size"] > 0:
                    log_debug(f"üëª Ïú†Î†π Ìè¨ÏßÄÏÖò Ï†ïÎ¶¨", f"{symbol} {side.upper()} Ìè¨ÏßÄÏÖò ÏÇ≠Ï†ú")
                    position_state[symbol][side] = get_default_pos_side_state()
                    if symbol in tpsl_storage and side in tpsl_storage[symbol]:
                        tpsl_storage[symbol][side].clear()

# ========
# 12. ÏñëÎ∞©Ìñ• Ï£ºÎ¨∏ Ïã§Ìñâ
# ========
def place_order(symbol, side, qty, signal_type, final_position_ratio=Decimal("0"), tv_sync_data=None):
    with position_lock:
        try:
            if side == "long":
                order_size = int(qty)
            else:
                order_size = -int(qty)
            
            order = FuturesOrder(
                contract=symbol, 
                size=order_size, 
                price="0", 
                tif="ioc"
            )
            
            result = _get_api_response(api.create_futures_order, SETTLE, order)
            if not result:
                log_debug(f"‚ùå Ï£ºÎ¨∏ Ïã§Ìñâ Ïã§Ìå® ({symbol}_{side.upper()})", "API Ìò∏Ï∂ú Ïã§Ìå®")
                return False
            
            log_debug(f"‚úÖ Ï£ºÎ¨∏ Ï†ÑÏÜ° ÏÑ±Í≥µ ({symbol}_{side.upper()})", f"Ï£ºÎ¨∏ ID: {getattr(result, 'id', 'Unknown')}")
            
            pos_side_state = position_state.setdefault(symbol, {
                "long": get_default_pos_side_state(), 
                "short": get_default_pos_side_state()
            })[side]
            
            pos_side_state["entry_count"] += 1
            
            if "premium" in signal_type:
                pos_side_state["premium_entry_count"] += 1
            elif "normal" in signal_type:
                pos_side_state["normal_entry_count"] += 1
            elif "rescue" in signal_type:
                pos_side_state["rescue_entry_count"] += 1
                
            if "rescue" not in signal_type and final_position_ratio > 0:
                pos_side_state['last_entry_ratio'] = final_position_ratio
                
            pos_side_state["entry_time"] = time.time()
            
            time.sleep(2)
            update_all_position_states()
            
            return True
            
        except Exception as e:
            log_debug(f"‚ùå Ï£ºÎ¨∏ ÏÉùÏÑ± Ïò§Î•ò ({symbol}_{side.upper()})", str(e), exc_info=True)
            return False

def close_position(symbol, side, reason="manual"):
    with position_lock:
        try:
            # üî• ÏàòÏ†ï: ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÏÇ¨Ïù¥Ï¶àÎ•º ÏßÅÏ†ë Ï°∞ÌöåÌï¥ÏÑú Î∞òÎåÄ Ï£ºÎ¨∏
            pos_side_state = position_state.get(symbol, {}).get(side, {})
            current_size = pos_side_state.get("size", Decimal("0"))
            
            if current_size <= 0:
                log_debug(f"‚ö†Ô∏è Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ ÏÉùÎûµ ({symbol}_{side.upper()})", "Ìè¨ÏßÄÏÖò ÏóÜÏùå")
                return True
            
            # Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞Ïùò Î∞òÎåÄ Ï£ºÎ¨∏ÏúºÎ°ú Ï≤≠ÏÇ∞
            if side == "long":
                order_size = -int(current_size)  # Î°± Ìè¨ÏßÄÏÖò Ï≤≠ÏÇ∞ÏùÄ ÏùåÏàò
            else:
                order_size = int(current_size)   # Ïàè Ìè¨ÏßÄÏÖò Ï≤≠ÏÇ∞ÏùÄ ÏñëÏàò
            
            order = FuturesOrder(
                contract=symbol, 
                size=order_size, 
                price="0", 
                tif="ioc"
            )
            
            result = _get_api_response(api.create_futures_order, SETTLE, order)
            if not result:
                log_debug(f"‚ùå Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ Ïã§Ìñâ Ïã§Ìå® ({symbol}_{side.upper()})", "API Ìò∏Ï∂ú Ïã§Ìå®")
                return False
            
            log_debug(f"‚úÖ Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ Ï†ÑÏÜ° ÏÑ±Í≥µ ({symbol}_{side.upper()})", f"ÏÇ¨Ïú†: {reason}, ÏàòÎüâ: {order_size}")
            
            # ÎÇ¥Î∂Ä ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            pos_side_state = position_state.setdefault(symbol, {
                "long": get_default_pos_side_state(), 
                "short": get_default_pos_side_state()
            })
            pos_side_state[side] = get_default_pos_side_state()
            
            if symbol in tpsl_storage and side in tpsl_storage[symbol]:
                tpsl_storage[symbol][side].clear()
                
            with signal_lock:
                recent_signals.pop(f"{symbol}_{side}", None)
            return True
            
        except Exception as e:
            log_debug(f"‚ùå Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ ÏÉùÏÑ± Ïò§Î•ò ({symbol}_{side.upper()})", str(e), exc_info=True)
            return False

# ========
# 13. Flask ÎùºÏö∞Ìä∏
# ========
@app.route("/ping", methods=["GET", "HEAD"])
def ping():
    return "pong", 200

@app.route("/clear-cache", methods=["POST"])
def clear_cache():
    with signal_lock: 
        recent_signals.clear()
    with tpsl_lock: 
        tpsl_storage.clear()
    log_debug("üîÑ Ï∫êÏãú Ï¥àÍ∏∞Ìôî", "Î™®Îì† Ïã†Ìò∏, TP/SL Ï∫êÏãúÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.")
    return jsonify({"status": "cache_cleared"})

@app.route("/status", methods=["GET"])
def status():
    try:
        equity = get_total_collateral(force=True)
        update_all_position_states()
        active_positions = {}
        
        with position_lock:
            for symbol, sides in position_state.items():
                for side, pos_data in sides.items():
                    if pos_data and pos_data.get("size", Decimal("0")) > 0:
                        pos_key = f"{symbol}_{side.upper()}"
                        active_positions[pos_key] = {
                            "side": side, "size": float(pos_data["size"]), "price": float(pos_data["price"]),
                            "value": float(pos_data["value"]), "entry_count": pos_data.get("entry_count", 0),
                            "normal_entry_count": pos_data.get("normal_entry_count", 0),
                            "premium_entry_count": pos_data.get("premium_entry_count", 0),
                            "rescue_entry_count": pos_data.get("rescue_entry_count", 0),
                            "last_entry_ratio": float(pos_data.get('last_entry_ratio', Decimal("0")))
                        }
        
        return jsonify({
            "status": "running", "version": "v6.25_simplified_tp",
            "current_time_kst": datetime.now(KST).strftime('%Y-%m-%d %H:%M:%S'),
            "balance_usdt": float(equity), "active_positions": active_positions,
            "tp_system": "Simple WebSocket Backup Only",
            "queue_info": {"size": task_q.qsize(), "max_size": task_q.maxsize}
        })
    except Exception as e:
        log_debug("‚ùå ÏÉÅÌÉú Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù", str(e), exc_info=True)
        return jsonify({"error": str(e)}), 500

@app.route("/", methods=["POST"])
def webhook():
    try:
        data = json.loads(request.get_data(as_text=True))
        log_debug("üì¨ ÏõπÌõÖ ÏàòÏã†", f"ÏàòÏã† Îç∞Ïù¥ÌÑ∞: {data}")
        
        action = data.get("action", "").lower()
        symbol = normalize_symbol(data.get("symbol", ""))
        side = data.get("side", "").lower()
        
        if not all([action, symbol, side]):
            log_debug("‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏõπÌõÖ", f"ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ: {data}")
            return jsonify({"error": "Invalid payload"}), 400
        
        if action == "entry":
            if is_duplicate(data):
                log_debug(f"üîÑ Ï§ëÎ≥µ Ïã†Ìò∏ Î¨¥Ïãú ({symbol}_{side.upper()})", "Ïø®Îã§Ïö¥ ÎÇ¥ Ï§ëÎ≥µ Ïã†Ìò∏")
                return jsonify({"status": "duplicate_ignored"}), 200
            
            # üî• Ï∂îÍ∞Ä: ÌèâÎã®Í∞Ä Îß§Ïπ≠ Ï≤òÎ¶¨
            expected_avg = data.get("expected_new_avg")
            if expected_avg:
                data["use_avg_matching"] = True
            
            task_q.put_nowait(data)
            log_debug(f"üì• ÏûëÏóÖ ÌÅê Ï∂îÍ∞Ä ({symbol}_{side.upper()})", f"ÌòÑÏû¨ ÌÅê ÌÅ¨Í∏∞: {task_q.qsize()}")
            return jsonify({"status": "queued"}), 200
            
        elif action == "exit":
            reason = data.get("reason", "").upper()
            price = data.get("price", 0)
            
            log_debug(f"üìù TV Ï≤≠ÏÇ∞ ÏïåÎ¶º ÏàòÏã† ({symbol}_{side.upper()})", 
                      f"ÏÇ¨Ïú†: {reason}, Í∞ÄÍ≤©: {price}")
            return jsonify({"status": "exit_logged_only"}), 200
            
        return jsonify({"error": "Invalid action"}), 400
    except Exception as e:
        log_debug("‚ùå ÏõπÌõÖ Ï≤òÎ¶¨ Ï§ë ÏòàÏô∏ Î∞úÏÉù", str(e), exc_info=True)
        return jsonify({"error": str(e)}), 500

# ========
# 14. üî• Í∞ÑÎã®Ìïú WebSocket TP Î™®ÎãàÌÑ∞ÎßÅ (Î≥µÏû°Ìïú ÏãúÏä§ÌÖú Ï†úÍ±∞)
# ========
async def price_monitor():
    uri = "wss://fx-ws.gateio.ws/v4/ws/usdt"
    symbols_to_subscribe = list(SYMBOL_CONFIG.keys())
    while True:
        try:
            async with websockets.connect(uri, ping_interval=20, ping_timeout=10) as ws:
                subscribe_msg = {
                    "time": int(time.time()), 
                    "channel": "futures.tickers", 
                    "event": "subscribe", 
                    "payload": symbols_to_subscribe
                }
                await ws.send(json.dumps(subscribe_msg))
                log_debug("üîå ÏõπÏÜåÏºì Íµ¨ÎèÖ", f"Ïã¨Î≥º: {len(symbols_to_subscribe)}Í∞ú")
                
                while True:
                    msg = await asyncio.wait_for(ws.recv(), timeout=15)
                    result = json.loads(msg).get("result")
                    if isinstance(result, list):
                        for item in result:
                            simple_tp_monitor(item)  # üî• Í∞ÑÎã®Ìïú TP Î™®ÎãàÌÑ∞ÎßÅ
                    elif isinstance(result, dict):
                        simple_tp_monitor(result)
                        
        except asyncio.TimeoutError:
            log_debug("üîå ÏõπÏÜåÏºì ÌÉÄÏûÑÏïÑÏõÉ", "15Ï¥à ÎÇ¥ Î©îÏãúÏßÄ ÏàòÏã† ÏóÜÏùå, Ïû¨Ïó∞Í≤∞")
        except Exception as e:
            log_debug("üîå ÏõπÏÜåÏºì Ïò§Î•ò", f"Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ... {type(e).__name__}: {str(e)}")
        
        await asyncio.sleep(3)

def simple_tp_monitor(ticker):
    """üî• Í∞ÑÎã®ÌïòÍ≥† ÌôïÏã§Ìïú TP Î™®ÎãàÌÑ∞ÎßÅ (Î≥µÏû°Ìïú ÏãúÏä§ÌÖú Ï†úÍ±∞)"""
    try:
        symbol = normalize_symbol(ticker.get("contract"))
        price = Decimal(str(ticker.get("last", "0")))
        
        if not symbol or symbol not in SYMBOL_CONFIG or price <= 0:
            return
            
        with position_lock:
            pos_side_state = position_state.get(symbol, {})
            
            # Î°± Ìè¨ÏßÄÏÖò TP Ï≤¥ÌÅ¨
            long_size = pos_side_state.get("long", {}).get("size", Decimal(0))
            if long_size > 0:
                long_pos = pos_side_state["long"]
                entry_price = long_pos.get("price")
                entry_time = long_pos.get("entry_time", time.time())
                
                if entry_price and entry_price > 0:
                    # Í∞ÑÎã®Ìïú TP Í≥ÑÏÇ∞ (ÏÑúÎ≤Ñ Í∏∞Ï§Ä 0.50% - Î≤ÑÌçº ÏóÜÏùå)
                    cfg = SYMBOL_CONFIG[symbol]
                    base_tp_pct = Decimal("0.005") * Decimal(str(cfg["tp_mult"]))
                    
                    # ÏãúÍ∞Ñ Í∞êÏá† Ï†ÅÏö©
                    time_elapsed = time.time() - entry_time
                    periods_15s = max(0, int(time_elapsed / 15))
                    tp_decay = Decimal("0.002") / 100 * Decimal(str(cfg["tp_mult"]))
                    tp_min = Decimal("0.12") / 100 * Decimal(str(cfg["tp_mult"]))
                    
                    current_tp_pct = max(tp_min, base_tp_pct - periods_15s * tp_decay)
                    tp_price = entry_price * (1 + current_tp_pct)
                    
                    if price >= tp_price:
                        log_debug(f"üéØ Î°± TP Ïã§Ìñâ ({symbol})", 
                                 f"ÌòÑÏû¨Í∞Ä: {price:.8f}, TPÍ∞Ä: {tp_price:.8f}, Ìè¨ÏßÄÏÖò: {long_size}")
                        close_position(symbol, "long", "TP")
            
            # Ïàè Ìè¨ÏßÄÏÖò TP Ï≤¥ÌÅ¨
            short_size = pos_side_state.get("short", {}).get("size", Decimal(0))
            if short_size > 0:
                short_pos = pos_side_state["short"]
                entry_price = short_pos.get("price")
                entry_time = short_pos.get("entry_time", time.time())
                
                if entry_price and entry_price > 0:
                    # Í∞ÑÎã®Ìïú TP Í≥ÑÏÇ∞ (ÏÑúÎ≤Ñ Í∏∞Ï§Ä 0.50% - Î≤ÑÌçº ÏóÜÏùå)
                    cfg = SYMBOL_CONFIG[symbol]
                    base_tp_pct = Decimal("0.005") * Decimal(str(cfg["tp_mult"]))
                    
                    # ÏãúÍ∞Ñ Í∞êÏá† Ï†ÅÏö©
                    time_elapsed = time.time() - entry_time
                    periods_15s = max(0, int(time_elapsed / 15))
                    tp_decay = Decimal("0.002") / 100 * Decimal(str(cfg["tp_mult"]))
                    tp_min = Decimal("0.12") / 100 * Decimal(str(cfg["tp_mult"]))
                    
                    current_tp_pct = max(tp_min, base_tp_pct - periods_15s * tp_decay)
                    tp_price = entry_price * (1 - current_tp_pct)
                    
                    if price <= tp_price:
                        log_debug(f"üéØ Ïàè TP Ïã§Ìñâ ({symbol})", 
                                 f"ÌòÑÏû¨Í∞Ä: {price:.8f}, TPÍ∞Ä: {tp_price:.8f}, Ìè¨ÏßÄÏÖò: {short_size}")
                        close_position(symbol, "short", "TP")
                
    except Exception as e:
        log_debug(f"‚ùå Í∞ÑÎã® TP Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò ({ticker.get('contract', 'Unknown')})", str(e))
            
            # Ïàè Ìè¨ÏßÄÏÖò TP Ï≤¥ÌÅ¨
            if pos_side_state.get("short", {}).get("size", Decimal(0)) > 0:
                short_pos = pos_side_state["short"]
                entry_price = short_pos.get("price")
                entry_time = short_pos.get("entry_time", time.time())
                
                if entry_price and entry_price > 0:
                    # Í∞ÑÎã®Ìïú TP Í≥ÑÏÇ∞ (ÏÑúÎ≤Ñ Í∏∞Ï§Ä 0.50% - Î≤ÑÌçº ÏóÜÏùå)
                    cfg = SYMBOL_CONFIG[symbol]
                    base_tp_pct = Decimal("0.005") * Decimal(str(cfg["tp_mult"]))
                    
                    # ÏãúÍ∞Ñ Í∞êÏá† Ï†ÅÏö©
                    time_elapsed = time.time() - entry_time
                    periods_15s = max(0, int(time_elapsed / 15))
                    tp_decay = Decimal("0.002") / 100 * Decimal(str(cfg["tp_mult"]))
                    tp_min = Decimal("0.12") / 100 * Decimal(str(cfg["tp_mult"]))
                    
                    current_tp_pct = max(tp_min, base_tp_pct - periods_15s * tp_decay)
                    tp_price = entry_price * (1 - current_tp_pct)
                    
                    if price <= tp_price:
                        log_debug(f"üéØ Ïàè TP Ïã§Ìñâ ({symbol})", 
                                 f"ÌòÑÏû¨Í∞Ä: {price:.8f}, TPÍ∞Ä: {tp_price:.8f}")
                        close_position(symbol, "short", "TP")
                
    except Exception as e:
        log_debug(f"‚ùå Í∞ÑÎã® TP Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò ({ticker.get('contract', 'Unknown')})", str(e))

# ========
# 15. ÏßÑÏûÖ Ï≤òÎ¶¨ Î°úÏßÅ
# ========
def worker(idx):
    while True:
        try:
            data = task_q.get(timeout=1)
            try:
                handle_entry(data)
            except Exception as e:
                log_debug(f"‚ùå ÏõåÏª§-{idx} Ï≤òÎ¶¨ Ïò§Î•ò", f"ÏûëÏóÖ Ï≤òÎ¶¨ Ï§ë ÏòàÏô∏: {str(e)}", exc_info=True)
            finally:
                task_q.task_done()
        except queue.Empty:
            continue
        except Exception as e:
            log_debug(f"‚ùå ÏõåÏª§-{idx} Ïã¨Í∞Å Ïò§Î•ò", f"ÏõåÏª§ Ïä§Î†àÎìú Ïò§Î•ò: {str(e)}", exc_info=True)

def handle_entry(data):
    symbol = normalize_symbol(data.get("symbol"))
    side = data.get("side", "").lower()
    base_type = data.get("type", "normal")
    signal_type = f"{base_type}_{side}"
    
    entry_score = data.get("entry_score", 50)
    signal_price_raw = data.get('price')
    tv_tp_pct = Decimal(str(data.get("tp_pct", "0.5"))) / 100
    sl_pct = Decimal(str(data.get("sl_pct", "4.0"))) / 100
    
    # üî• Ï∂îÍ∞Ä: ÌèâÎã®Í∞Ä Îß§Ïπ≠ Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞
    expected_new_avg = data.get("expected_new_avg")
    use_avg_matching = data.get("use_avg_matching", False)
    
    if not all([symbol, side, signal_price_raw]):
        log_debug("‚ùå ÏßÑÏûÖ Ï≤òÎ¶¨ Î∂àÍ∞Ä", f"ÌïÑÏàò Ï†ïÎ≥¥ ÎàÑÎùΩ")
        return
    
    cfg = SYMBOL_CONFIG.get(symbol)
    if not cfg:
        return log_debug(f"‚ö†Ô∏è ÏßÑÏûÖ Ï∑®ÏÜå ({symbol})", "ÎØ∏ÏßÄÏõê Ïã¨Î≥º")
        
    current_price = get_price(symbol)
    price_multiplier = cfg.get("price_multiplier", Decimal("1.0"))
    signal_price = Decimal(str(signal_price_raw)) / price_multiplier
    
    if current_price <= 0 or signal_price <= 0:
        return log_debug(f"‚ùå ÏßÑÏûÖ Ï∑®ÏÜå ({symbol})", f"Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Í∞ÄÍ≤©")
    
    price_diff = abs(current_price - signal_price)
    allowed_slippage = max(signal_price * PRICE_DEVIATION_LIMIT_PCT, Decimal(str(MAX_SLIPPAGE_TICKS)) * cfg['tick_size'])
    if price_diff > allowed_slippage:
        return log_debug(f"‚ö†Ô∏è ÏßÑÏûÖ Ï∑®ÏÜå: Ïä¨Î¶¨ÌîºÏßÄ ({symbol}_{side.upper()})", f"Í∞ÄÍ≤© Ï∞®Ïù¥ Ï¥àÍ≥º")
        
    update_all_position_states()
    pos_side_state = position_state.get(symbol, {}).get(side, {})
    
    # üî• ÏàòÏ†ï: Ï¥ù ÏßÑÏûÖ Ï†úÌïúÏùÑ 13ÏúºÎ°ú Î≥ÄÍ≤Ω
    entry_limits = {"premium": 5, "normal": 5, "rescue": 3}
    total_entry_limit = 13  # üî• 10ÏóêÏÑú 13ÏúºÎ°ú ÏàòÏ†ï
    
    entry_type_key = next((k for k in entry_limits if k in signal_type), None)

    if pos_side_state.get("entry_count", 0) >= total_entry_limit:
        log_debug(f"‚ö†Ô∏è Ï∂îÍ∞Ä ÏßÑÏûÖ Ï†úÌïú ({symbol}_{side.upper()})", f"Ï¥ù ÏßÑÏûÖ ÌöüÏàò ÏµúÎåÄÏπò ÎèÑÎã¨: {total_entry_limit}")
        return

    if entry_type_key and pos_side_state.get(f"{entry_type_key}_entry_count", 0) >= entry_limits[entry_type_key]:
        log_debug(f"‚ö†Ô∏è Ï∂îÍ∞Ä ÏßÑÏûÖ Ï†úÌïú ({symbol}_{side.upper()})", f"'{entry_type_key}' Ïú†Ìòï ÏµúÎåÄÏπò ÎèÑÎã¨: {entry_limits[entry_type_key]}")
        return

    if pos_side_state.get("size", Decimal(0)) > 0 and "rescue" not in signal_type:
        avg_price = pos_side_state.get("price")
        if avg_price and ((side == "long" and current_price <= avg_price) or (side == "short" and current_price >= avg_price)):
            return log_debug(f"‚ö†Ô∏è Ï∂îÍ∞Ä ÏßÑÏûÖ Î≥¥Î•ò ({symbol}_{side.upper()})", f"ÌèâÎã®Í∞Ä Î∂àÎ¶¨")

    current_signal_count = pos_side_state.get("premium_entry_count", 0) if "premium" in signal_type else pos_side_state.get("normal_entry_count", 0)
    
    # üî• ÌèâÎã®Í∞Ä Îß§Ïπ≠ ÏàòÎüâ Í≥ÑÏÇ∞ ÏãúÎèÑ
    if use_avg_matching and expected_new_avg:
        matched_qty = calculate_qty_to_match_avg_price(symbol, expected_new_avg)
        if matched_qty and matched_qty > 0:
            # ÌèâÎã®Í∞Ä Îß§Ïπ≠ÏúºÎ°ú ÏàòÎüâ Í≤∞Ï†ï
            qty = matched_qty
            log_debug(f"üìä ÌèâÎã®Í∞Ä Îß§Ïπ≠ ÏàòÎüâ Ï†ÅÏö© ({symbol}_{side.upper()})", 
                      f"Î™©ÌëúÌèâÎã®: {expected_new_avg}, Îß§Ïπ≠ÏàòÎüâ: {qty}")
        else:
            # ÌèâÎã®Í∞Ä Îß§Ïπ≠ Ïã§Ìå®Ïãú Í∏∞Î≥∏ Í≥ÑÏÇ∞
            qty = calculate_position_size(symbol, signal_type, entry_score, current_signal_count)
    else:
        # Í∏∞Î≥∏ ÏàòÎüâ Í≥ÑÏÇ∞
        qty = calculate_position_size(symbol, signal_type, entry_score, current_signal_count)
    
    final_position_ratio = Decimal("0")
    
    if "rescue" in signal_type:
        last_ratio = pos_side_state.get('last_entry_ratio', Decimal("5.0"))
        if last_ratio > 0:
            equity, contract_val = get_total_collateral(), get_price(symbol) * cfg["contract_size"]
            if contract_val > 0:
                rescue_ratio = last_ratio * Decimal("1.5")
                qty = max((equity * rescue_ratio / 100 / contract_val).quantize(Decimal('1'), rounding=ROUND_DOWN), cfg["min_qty"])
                final_position_ratio = rescue_ratio
    
    if qty > 0:
        entry_action = "Ï∂îÍ∞ÄÏßÑÏûÖ" if pos_side_state.get("size", 0) > 0 else "Ï≤´ÏßÑÏûÖ"
        if place_order(symbol, side, qty, signal_type, final_position_ratio):
            update_all_position_states()
            latest_pos_side_state = position_state.get(symbol, {}).get(side, {})
            log_debug(f"‚úÖ {entry_action} ÏÑ±Í≥µ ({symbol}_{side.upper()})", 
                      f"Ïú†Ìòï: {signal_type}, ÏàòÎüâ: {float(qty)} Í≥ÑÏïΩ (Ï¥ù ÏßÑÏûÖ: {latest_pos_side_state.get('entry_count',0)}/13)")
            store_tp_sl(symbol, side, tv_tp_pct, sl_pct, abs(current_price - signal_price) / signal_price, latest_pos_side_state.get("entry_count", 0))
        else:
            log_debug(f"‚ùå {entry_action} Ïã§Ìå® ({symbol}_{side.upper()})", "Ï£ºÎ¨∏ Ïã§Ìñâ Ï§ë Ïò§Î•ò")

# ========
# 16. Ìè¨ÏßÄÏÖò Î™®ÎãàÌÑ∞ÎßÅ
# ========
def position_monitor():
    while True:
        time.sleep(30)
        try:
            update_all_position_states()
            total_value = Decimal("0")
            active_positions_log = []
            
            with position_lock:
                for symbol, sides in position_state.items():
                    for side, pos_data in sides.items():
                        if pos_data and pos_data.get("size", Decimal("0")) > 0:
                            total_value += pos_data.get("value", Decimal("0"))
                            pyramid_info = f"Ï¥ù:{pos_data['entry_count']}/13,Ïùº:{pos_data['normal_entry_count']}/5,ÌîÑ:{pos_data['premium_entry_count']}/5,Î†à:{pos_data['rescue_entry_count']}/3"
                            active_positions_log.append(f"{symbol}_{side.upper()}: {pos_data['size']:.4f} @ {pos_data['price']:.8f} ({pyramid_info}, Í∞ÄÏπò: {pos_data['value']:.2f} USDT)")
            
            if active_positions_log:
                equity = get_total_collateral()
                exposure_pct = (total_value / equity * 100) if equity > 0 else 0
                log_debug("üöÄ Ìè¨ÏßÄÏÖò ÌòÑÌô©", f"ÌôúÏÑ±: {len(active_positions_log)}Í∞ú, Ï¥ùÍ∞ÄÏπò: {total_value:.2f} USDT, ÎÖ∏Ï∂úÎèÑ: {exposure_pct:.1f}%")
                for pos_info in active_positions_log:
                    log_debug("  ‚îî", pos_info)
            else:
                log_debug("üìä Ìè¨ÏßÄÏÖò ÌòÑÌô©", "ÌôúÏÑ± Ìè¨ÏßÄÏÖò ÏóÜÏùå")
                
        except Exception as e:
            log_debug("‚ùå Ìè¨ÏßÄÏÖò Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò", str(e), exc_info=True)

# ========
# 17. Î©îÏù∏ Ïã§Ìñâ
# ========
if __name__ == "__main__":
    log_debug("üöÄ ÏÑúÎ≤Ñ ÏãúÏûë", "Gate.io ÏûêÎèôÎß§Îß§ ÏÑúÎ≤Ñ v6.25 (TP ÏãúÏä§ÌÖú Í∞ÑÏÜåÌôî)")
    log_debug("üéØ TP ÏãúÏä§ÌÖú", "Í∞ÑÎã®Ìïú WebSocket Î∞±ÏóÖ TPÎßå ÏÇ¨Ïö© (Î≥µÏû°Ìïú API TP Ï†úÍ±∞)")
    log_debug("üîß Ï£ºÏöî Í∞úÏÑ†", "SOL Ïã¨Î≥º Ïù∏Ïãù, Ï¥ù ÏßÑÏûÖ Ï†úÌïú 13Ìöå, ÌèâÎã®Í∞Ä Îß§Ïπ≠ ÏßÄÏõê")
    
    initialize_states()
    
    log_debug("üìä Ï¥àÍ∏∞ ÏÉÅÌÉú Î°úÎìú", "ÌòÑÏû¨ Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥ Î∂àÎü¨Ïò§Îäî Ï§ë...")
    update_all_position_states()
    
    initial_active_positions = []
    with position_lock:
        for symbol, sides in position_state.items():
            for side, pos_data in sides.items():
                if pos_data and pos_data.get("size", Decimal("0")) > 0:
                    initial_active_positions.append(
                        f"{symbol}_{side.upper()}: {pos_data['size']:.4f} @ {pos_data.get('price', 0):.8f}"
                    )
    
    log_debug("üìä Ï¥àÍ∏∞ ÌôúÏÑ± Ìè¨ÏßÄÏÖò", f"{len(initial_active_positions)}Í∞ú Í∞êÏßÄ" if initial_active_positions else "Í∞êÏßÄ ÏïàÎê®")
    for pos_info in initial_active_positions:
        log_debug("  ‚îî", pos_info)
        
    equity = get_total_collateral(force=True)
    log_debug("üí∞ Ï¥àÍ∏∞ ÏûêÏÇ∞", f"{equity:.2f} USDT" if equity > 0 else "Ï°∞Ìöå Ïã§Ìå®")
    
    # Î∞±Í∑∏ÎùºÏö¥Îìú Ïä§Î†àÎìú ÏãúÏûë
    threading.Thread(target=position_monitor, daemon=True, name="PositionMonitor").start()
    threading.Thread(target=lambda: asyncio.run(price_monitor()), daemon=True, name="SimpleTPMonitor").start()
    
    # ÏõåÏª§ Ïä§Î†àÎìú ÏãúÏûë
    for i in range(WORKER_COUNT):
        threading.Thread(target=worker, args=(i,), daemon=True, name=f"Worker-{i}").start()
    
    port = int(os.environ.get("PORT", 8080))
    log_debug("üåê Ïõπ ÏÑúÎ≤Ñ ÏãúÏûë", f"Flask ÏÑúÎ≤Ñ 0.0.0.0:{port}")
    log_debug("‚úÖ Ï§ÄÎπÑ ÏôÑÎ£å", "Í∞ÑÏÜåÌôîÎêú TP ÏãúÏä§ÌÖú + ÌèâÎã®Í∞Ä Îß§Ïπ≠ ÏßÄÏõê")
    
    try:
        app.run(host="0.0.0.0", port=port, debug=False, threaded=True)
    except Exception as e:
        log_debug("‚ùå ÏÑúÎ≤Ñ Ïã§Ìñâ Ïã§Ìå®", str(e), exc_info=True)
        sys.exit(1)
