#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gate.io ÏûêÎèôÎß§Îß§ ÏÑúÎ≤Ñ v6.33-server - ÌååÏù∏Ïä§ÌÅ¨Î¶ΩÌä∏ v6.33 Ïó∞Îèô ÏµúÏ¢ÖÎ≥∏
(Í∏∞Ï°¥ v6.26 Í∏∞Î∞ò ÏàòÏ†ï)
"""
import os
import json
import time
import asyncio
import threading
import websockets
import logging
import sys
from decimal import Decimal, ROUND_DOWN
from datetime import datetime
from flask import Flask, request, jsonify
from gate_api import ApiClient, Configuration, FuturesApi, FuturesOrder, UnifiedApi
from gate_api import exceptions as gate_api_exceptions
import queue
import pytz
import urllib.parse 

# ========
# 1. Î°úÍπÖ ÏÑ§Ï†ï
# ========
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(levelname)s] %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)
logging.getLogger('werkzeug').setLevel(logging.ERROR)

def log_debug(tag, msg, exc_info=False):
    logger.info(f"[{tag}] {msg}")
    if exc_info:
        logger.exception("")

# ========
# 2. Flask Ïï± Î∞è API ÏÑ§Ï†ï
# ========
try:
    app = Flask(__name__)
    logger.info("Flask Ïï± Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
except Exception as e:
    logger.error(f"Flask Ïï± Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
    try:
        app = Flask("gate_trading_server")
        logger.info("ÎåÄÏïà Flask Ïï± Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
    except Exception as e2:
        logger.critical(f"Flask Ïï± Ï¥àÍ∏∞Ìôî ÏôÑÏ†Ñ Ïã§Ìå®: {e2}")
        sys.exit(1)

API_KEY = os.environ.get("API_KEY", "")
API_SECRET = os.environ.get("API_SECRET", "")
SETTLE = "usdt"

if not API_KEY or not API_SECRET:
    logger.critical("API_KEY ÎòêÎäî API_SECRETÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
    sys.exit(1)

try:
    config = Configuration(key=API_KEY, secret=API_SECRET)
    client = ApiClient(config)
    api = FuturesApi(client)
    unified_api = UnifiedApi(client)
    logger.info("Gate.io API Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
except Exception as e:
    logger.critical(f"Gate.io API Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
    sys.exit(1)

# ========
# 3. ÏÉÅÏàò Î∞è ÏÑ§Ï†ï
# ========
# üî• ÏàòÏ†ï: ÏõπÌõÖ Ï§ëÎ≥µ Ï†ÑÏÜ° Î∞©ÏßÄÎ•º ÏúÑÌïú ÏµúÏÜå ÏïàÏ†ÑÏû•Ïπò (5Ï¥à)
COOLDOWN_SECONDS = 5
PRICE_DEVIATION_LIMIT_PCT = Decimal("0.0003")
MAX_SLIPPAGE_TICKS = 5
KST = pytz.timezone('Asia/Seoul')

PREMIUM_TP_MULTIPLIERS = {
    "first_entry": Decimal("1.5"),
    "after_normal": Decimal("1.3"),
    "after_premium": Decimal("1.2")
}

SYMBOL_MAPPING = {
    "BTCUSDT": "BTC_USDT", "BTCUSDT.P": "BTC_USDT", "BTCUSDTPERP": "BTC_USDT", "BTC_USDT": "BTC_USDT", "BTC": "BTC_USDT",
    "ETHUSDT": "ETH_USDT", "ETHUSDT.P": "ETH_USDT", "ETHUSDTPERP": "ETH_USDT", "ETH_USDT": "ETH_USDT", "ETH": "ETH_USDT",
    "SOLUSDT": "SOL_USDT", "SOLUSDT.P": "SOL_USDT", "SOLUSDTPERP": "SOL_USDT", "SOL_USDT": "SOL_USDT", "SOL": "SOL_USDT",
    "ADAUSDT": "ADA_USDT", "ADAUSDT.P": "ADA_USDT", "ADAUSDTPERP": "ADA_USDT", "ADA_USDT": "ADA_USDT", "ADA": "ADA_USDT",
    "SUIUSDT": "SUI_USDT", "SUIUSDT.P": "SUI_USDT", "SUIUSDTPERP": "SUI_USDT", "SUI_USDT": "SUI_USDT", "SUI": "SUI_USDT",
    "LINKUSDT": "LINK_USDT", "LINKUSDT.P": "LINK_USDT", "LINKUSDTPERP": "LINK_USDT", "LINK_USDT": "LINK_USDT", "LINK": "LINK_USDT",
    "PEPEUSDT": "PEPE_USDT", "PEPEUSDT.P": "PEPE_USDT", "PEPEUSDTPERP": "PEPE_USDT", "PEPE_USDT": "PEPE_USDT", "PEPE": "PEPE_USDT",
    "XRPUSDT": "XRP_USDT", "XRPUSDT.P": "XRP_USDT", "XRPUSDTPERP": "XRP_USDT", "XRP_USDT": "XRP_USDT", "XRP": "XRP_USDT",
    "DOGEUSDT": "DOGE_USDT", "DOGEUSDT.P": "DOGE_USDT", "DOGEUSDTPERP": "DOGE_USDT", "DOGE_USDT": "DOGE_USDT", "DOGE": "DOGE_USDT",
    "ONDOUSDT": "ONDO_USDT", "ONDOUSDT.P": "ONDO_USDT", "ONDOUSDTPERP": "ONDO_USDT", "ONDO_USDT": "ONDO_USDT", "ONDO": "ONDO_USDT",
}

DEFAULT_SYMBOL_CONFIG = {
    "min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), 
    "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.001")
}

SYMBOL_CONFIG = {
    "BTC_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("0.0001"), "min_notional": Decimal("5"), "tp_mult": 0.55, "sl_mult": 0.55, "tick_size": Decimal("0.1")},
    "ETH_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("0.01"), "min_notional": Decimal("5"), "tp_mult": 0.65, "sl_mult": 0.65, "tick_size": Decimal("0.01")},
    "SOL_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 0.8, "sl_mult": 0.8, "tick_size": Decimal("0.001")},
    "ADA_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.0001")},
    "SUI_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.001")},
    "LINK_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.001")},
    "PEPE_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10000000"), "min_notional": Decimal("5"), "tp_mult": 1.2, "sl_mult": 1.2, "tick_size": Decimal("0.00000001"), "price_multiplier": Decimal("100000000.0")},
    "XRP_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.0001")},
    "DOGE_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("10"), "min_notional": Decimal("5"), "tp_mult": 1.2, "sl_mult": 1.2, "tick_size": Decimal("0.00001")},
    "ONDO_USDT": {"min_qty": Decimal("1"), "qty_step": Decimal("1"), "contract_size": Decimal("1"), "min_notional": Decimal("5"), "tp_mult": 1.0, "sl_mult": 1.0, "tick_size": Decimal("0.0001")}
}

def get_symbol_config(symbol):
    if symbol in SYMBOL_CONFIG: return SYMBOL_CONFIG[symbol]
    log_debug(f"‚ö†Ô∏è ÎàÑÎùΩÎêú Ïã¨Î≥º ÏÑ§Ï†ï ({symbol})", "Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏßÑÌñâ")
    SYMBOL_CONFIG[symbol] = DEFAULT_SYMBOL_CONFIG.copy()
    return SYMBOL_CONFIG[symbol]

# ========
# 4. ÏÉÅÌÉú Í¥ÄÎ¶¨
# ========
position_state = {}
position_lock = threading.RLock()
account_cache = {"time": 0, "data": None}
recent_signals = {}
signal_lock = threading.RLock()
tpsl_storage = {}
tpsl_lock = threading.RLock()
task_q = queue.Queue(maxsize=100)
WORKER_COUNT = min(6, max(2, os.cpu_count() * 2))
manual_close_protection = {}
manual_protection_lock = threading.RLock()

def get_default_pos_side_state():
    return {"price": None, "size": Decimal("0"), "value": Decimal("0"), "entry_count": 0, "normal_entry_count": 0, "premium_entry_count": 0, "rescue_entry_count": 0, "entry_time": None, 'last_entry_ratio': Decimal("0")}

def initialize_states():
    with position_lock, tpsl_lock:
        for sym in SYMBOL_CONFIG:
            position_state[sym] = {"long": get_default_pos_side_state(), "short": get_default_pos_side_state()}
            tpsl_storage[sym] = {"long": {}, "short": {}}

# ========
# 5. ÌïµÏã¨ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
# ========
def set_manual_close_protection(symbol, side, duration=30):
    with manual_protection_lock:
        key = f"{symbol}_{side}"
        manual_close_protection[key] = {"protected_until": time.time() + duration, "reason": "manual_close_detected"}
        log_debug(f"üõ°Ô∏è ÏàòÎèô Ï≤≠ÏÇ∞ Î≥¥Ìò∏ ÌôúÏÑ±Ìôî ({key})", f"{duration}Ï¥àÍ∞Ñ ÏûêÎèô TP Ï∞®Îã®")

def is_manual_close_protected(symbol, side):
    with manual_protection_lock:
        key = f"{symbol}_{side}"
        if key in manual_close_protection and time.time() < manual_close_protection[key]["protected_until"]: return True
        elif key in manual_close_protection:
            del manual_close_protection[key]
            log_debug(f"üõ°Ô∏è ÏàòÎèô Ï≤≠ÏÇ∞ Î≥¥Ìò∏ Ìï¥Ï†ú ({key})", "Î≥¥Ìò∏ ÏãúÍ∞Ñ ÎßåÎ£å")
    return False

def _get_api_response(api_call, *args, **kwargs):
    for attempt in range(3):
        try: return api_call(*args, **kwargs)
        except Exception as e:
            error_msg = str(e)
            if isinstance(e, gate_api_exceptions.ApiException): error_msg = f"API Error {e.status}: {e.body or e.reason}"
            if attempt < 2: log_debug("‚ö†Ô∏è API Ìò∏Ï∂ú Ïû¨ÏãúÎèÑ", f"ÏãúÎèÑ {attempt+1}/3: {error_msg}")
            else: log_debug("‚ùå API Ìò∏Ï∂ú ÏµúÏ¢Ö Ïã§Ìå®", error_msg, exc_info=True)
            time.sleep(1)
    return None

def normalize_symbol(raw_symbol):
    if not raw_symbol: return None
    symbol = str(raw_symbol).upper().strip()
    if symbol in SYMBOL_MAPPING: return SYMBOL_MAPPING[symbol]
    if "SOL" in symbol: return "SOL_USDT"
    clean_symbol = symbol.replace('.P', '').replace('PERP', '').replace('USDT', '')
    for key, value in SYMBOL_MAPPING.items():
        if clean_symbol in key: return value
    log_debug("‚ö†Ô∏è Ïã¨Î≥º Ï†ïÍ∑úÌôî Ïã§Ìå®", f"'{raw_symbol}' ‚Üí Îß§ÌïëÎêòÏßÄ ÏïäÏùå")
    return symbol

def get_total_collateral(force=False):
    now = time.time()
    if not force and account_cache.get("data") and account_cache.get("time", 0) > now - 30: return account_cache["data"]
    acc = _get_api_response(api.list_futures_accounts, SETTLE)
    equity = Decimal(str(getattr(acc, 'total', '0'))) if acc else Decimal("0")
    account_cache.update({"time": now, "data": equity})
    return equity

def get_price(symbol):
    ticker = _get_api_response(api.list_futures_tickers, SETTLE, contract=symbol)
    return Decimal(str(ticker[0].last)) if ticker and len(ticker) > 0 else Decimal("0")

# ========
# 6. ÌååÏù∏Ïä§ÌÅ¨Î¶ΩÌä∏ Ïó∞Îèô Î∞è ÏàòÎüâÍ≥ÑÏÇ∞ Ìï®Ïàò
# ========
def get_signal_type_multiplier(signal_type):
    if "premium" in signal_type: return Decimal("2.0")
    # üî• ÏàòÏ†ï: Î†àÏä§ÌÅê Ï¶ùÌè≠Î•† 3Î∞∞ Ï†ÅÏö©
    if "rescue" in signal_type: return Decimal("3.0")
    return Decimal("1.0")

def get_entry_weight_from_score(score):
    try:
        score = Decimal(str(score))
        if score <= 10: return Decimal("0.25")
        if score <= 30: return Decimal("0.35")
        if score <= 50: return Decimal("0.50")
        if score <= 70: return Decimal("0.65")
        if score <= 90: return Decimal("0.80")
        return Decimal("1.00")
    except: return Decimal("0.25")

def get_ratio_by_index(idx):
    # üî• ÏàòÏ†ï: ÌååÏù∏Ïä§ÌÅ¨Î¶ΩÌä∏ÏôÄ ÎèôÏùºÌïú ÏßÑÏûÖ ÎπÑÏú®Î°ú Î≥ÄÍ≤Ω
    ratios = [Decimal("3.0"), Decimal("7.0"), Decimal("20.0"), Decimal("50.0"), Decimal("120.0")]
    return ratios[min(idx, len(ratios) - 1)]

def store_tp_sl(symbol, side, tp, sl, entry_number):
    with tpsl_lock:
        tpsl_storage.setdefault(symbol, {"long": {}, "short": {}})[side][entry_number] = {"tp": tp, "sl": sl, "entry_time": time.time()}

def is_duplicate(data):
    with signal_lock:
        now = time.time()
        symbol_id = f"{data.get('symbol')}_{data.get('side')}_{data.get('type')}"
        if now - recent_signals.get(symbol_id, 0) < COOLDOWN_SECONDS:
            log_debug(f"üîÑ Ï§ëÎ≥µ Ïã†Ìò∏ Î¨¥Ïãú ({symbol_id})", f"{COOLDOWN_SECONDS}Ï¥à ÎÇ¥ Ï§ëÎ≥µ Ïã†Ìò∏")
            return True
        recent_signals[symbol_id] = now
        recent_signals.update({k: v for k, v in recent_signals.items() if now - v < 300})
        return False

def calculate_position_size(symbol, signal_type, entry_score, current_signal_count):
    cfg, equity, price = get_symbol_config(symbol), get_total_collateral(), get_price(symbol)
    if equity <= 0 or price <= 0:
        return Decimal("0"), Decimal("0")
    
    base_ratio = get_ratio_by_index(current_signal_count)
    signal_multiplier = get_signal_type_multiplier(signal_type)
    score_weight = get_entry_weight_from_score(entry_score)
    final_ratio = base_ratio * signal_multiplier * score_weight
    
    # Î†àÏä§ÌÅêÎäî Ïù¥Ï†Ñ ÎπÑÏú® Í∏∞Ï§Ä
    if "rescue" in signal_type:
        with position_lock:
            # üî• Ï∂îÍ∞Ä: 'side' Î≥ÄÏàòÍ∞Ä ÏóÜÏñ¥ÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌï† Ïàò ÏûàÏúºÎØÄÎ°ú Ï∂îÍ∞ÄÌï©ÎãàÎã§.
            side = "long" if "long" in signal_type else "short"
            last_ratio = position_state.get(symbol, {}).get(side, {}).get('last_entry_ratio', Decimal("5.0"))
            final_ratio = last_ratio * signal_multiplier
            
    contract_value = price * cfg["contract_size"]
    if contract_value <= 0:
        return Decimal("0"), final_ratio
    
    # üî• ÏàòÏ†ï: Î≥ÄÏàòÎ™ÖÏùÑ 'final_position_ratio'ÏóêÏÑú 'final_ratio'Î°ú Î≥ÄÍ≤Ω
    position_value = equity * final_ratio / 100
    base_qty = (position_value / contract_value).quantize(Decimal('1'), rounding=ROUND_DOWN)
    
    qty_with_min = max(base_qty, cfg["min_qty"])
    
    if qty_with_min * contract_value < cfg["min_notional"]:
        final_qty = (cfg["min_notional"] / contract_value).quantize(Decimal('1'), rounding=ROUND_DOWN) + Decimal("1")
    else:
        final_qty = qty_with_min
        
    # üî• ÏàòÏ†ï: Î∞òÌôòÍ∞íÏóê qtyÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ ÏûàÏóàÏäµÎãàÎã§.
    return final_qty, final_ratio

# ========
# 7. Ï£ºÎ¨∏ Î∞è ÏÉÅÌÉú Í¥ÄÎ¶¨
# ========
def place_order(symbol, side, qty):
    with position_lock:
        try:
            # Ï£ºÎ¨∏ Ï†Ñ ÏÉÅÌÉú ÌôïÏù∏ÏùÑ ÏúÑÌï¥ Î®ºÏ†Ä Ìò∏Ï∂ú
            update_all_position_states()
            original_size = position_state.get(symbol, {}).get(side, {}).get("size", Decimal("0"))
            
            order = FuturesOrder(contract=symbol, size=int(qty) if side == "long" else -int(qty), price="0", tif="ioc")
            result = _get_api_response(api.create_futures_order, SETTLE, order)
            
            if not result: 
                log_debug(f"‚ùå Ï£ºÎ¨∏ API Ìò∏Ï∂ú Ïã§Ìå® ({symbol}_{side.upper()})", "Í≤∞Í≥º ÏóÜÏùå")
                return False

            log_debug(f"‚úÖ Ï£ºÎ¨∏ Ï†ÑÏÜ° ({symbol}_{side.upper()})", f"ID: {getattr(result, 'id', 'N/A')}")
            
            # ‚ñº‚ñº‚ñº [ÌïµÏã¨ ÏàòÏ†ï] API ÏßÄÏó∞Ïóê ÎåÄÏùëÌïòÍ∏∞ ÏúÑÌï¥ ÎåÄÍ∏∞ ÏãúÍ∞ÑÏùÑ 5Ï¥à -> 15Ï¥àÎ°ú ÎäòÎ¶º ‚ñº‚ñº‚ñº
            for attempt in range(15):
                time.sleep(1)
                update_all_position_states()
                current_size = position_state.get(symbol, {}).get(side, {}).get("size", Decimal("0"))
                if current_size > original_size:
                    log_debug(f"üîÑ Ìè¨ÏßÄÏÖò ÏóÖÎç∞Ïù¥Ìä∏ ÌôïÏù∏ ({symbol}_{side.upper()})", f"{attempt+1}Ï¥à ÏÜåÏöî")
                    return True
            # ‚ñ≤‚ñ≤‚ñ≤ [ÏàòÏ†ï ÏôÑÎ£å] ‚ñ≤‚ñ≤‚ñ≤
            
            log_debug(f"‚ùå Ìè¨ÏßÄÏÖò ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå® ({symbol}_{side.upper()})", "15Ï¥à ÌõÑÏóêÎèÑ Î≥ÄÍ≤Ω ÏóÜÏùå. API ÏßÄÏó∞ Í∞ÄÎä•ÏÑ± ÎÜíÏùå.")
            return False
        except Exception as e:
            log_debug(f"‚ùå Ï£ºÎ¨∏ Ïò§Î•ò ({symbol}_{side.upper()})", str(e), exc_info=True)
            return False

def update_all_position_states():
    """üî• ÏµúÏ¢Ö ÏïàÏ†ïÏÑ± Í∞ïÌôî: API Ï°∞Ìöå Ïã§Ìå® Ïãú, Í∏∞Ï°¥ Ìè¨ÏßÄÏÖò ÏÉÅÌÉúÎ•º Ïú†ÏßÄÌïòÏó¨ 'ÏÇ¨ÎùºÏßÄÎäî Ìè¨ÏßÄÏÖò' Î≤ÑÍ∑∏Î•º ÏôÑÎ≤ΩÌûà Ìï¥Í≤∞"""
    with position_lock:
        api_positions = None
        api_source = "None"
        
        # 1. ÌÜµÌï© Í≥ÑÏ†ï(Unified Account) Î®ºÏ†Ä ÌôïÏù∏
        unified_positions = _get_api_response(unified_api.list_unified_positions, SETTLE)
        
        # ‚ñº‚ñº‚ñº [ÌïµÏã¨] API Ìò∏Ï∂úÏù¥ ÏÑ±Í≥µÌñàÏùÑ ÎïåÎßå(Í≤∞Í≥ºÍ∞Ä NoneÏù¥ ÏïÑÎãê Îïå) api_positionsÏóê Í∞íÏùÑ Ìï†Îãπ ‚ñº‚ñº‚ñº
        if unified_positions is not None:
            api_positions = unified_positions
            api_source = "UnifiedApi"
        else:
            # ÌÜµÌï© Í≥ÑÏ†ï API Ìò∏Ï∂ú Ïã§Ìå® Ïãú, ÌÅ¥ÎûòÏãù ÏÑ†Î¨º Í≥ÑÏ†ïÏúºÎ°ú Ïû¨ÏãúÎèÑ
            futures_positions = _get_api_response(api.list_positions, SETTLE)
            if futures_positions is not None:
                api_positions = futures_positions
                api_source = "FuturesApi"
        
        # ‚ñº‚ñº‚ñº [Îß§Ïö∞ Ï§ëÏöî] Îëê API Î™®ÎëêÏóêÏÑú Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÎã§Î©¥, Ìï®ÏàòÎ•º Ï¶âÏãú Ï¢ÖÎ£åÌïòÏó¨ Í∏∞Ï°¥ ÏÉÅÌÉúÎ•º Î≥¥Ï°¥! ‚ñº‚ñº‚ñº
        if api_positions is None:
            log_debug("‚ùå Ìè¨ÏßÄÏÖò ÎèôÍ∏∞Ìôî Ïã§Ìå®", "API ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏùëÎãµ ÏóÜÏùå. Ïù¥Ï†Ñ Ìè¨ÏßÄÏÖò ÏÉÅÌÉúÎ•º Ïú†ÏßÄÌï©ÎãàÎã§.")
            return

        log_debug("üìä Ìè¨ÏßÄÏÖò ÎèôÍ∏∞Ìôî ÏãúÏûë", f"Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§: {api_source}, Ï∞æÏùÄ Ìè¨ÏßÄÏÖò Ïàò: {len(api_positions)}")
        
        active_positions_set = set()
        
        for pos in api_positions: # ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏Ïò® API Í≤∞Í≥ºÎ°úÎßå Ï≤òÎ¶¨
            symbol = normalize_symbol(pos.contract)
            if not symbol: continue
            if symbol not in position_state: initialize_states()
            
            cfg = get_symbol_config(symbol)
            pos_size = Decimal(str(pos.size))
            
            if hasattr(pos, 'mode') and pos.mode in ['dual_long', 'dual_short']:
                side = 'long' if pos.mode == 'dual_long' else 'short'
                state = position_state[symbol][side]
                state.update({
                    "price": Decimal(str(pos.entry_price)), "size": pos_size,
                    "value": pos_size * Decimal(str(pos.mark_price)) * cfg["contract_size"]
                })
                active_positions_set.add((symbol, side))
            else:
                if pos_size > 0:
                    side = 'long'
                    state = position_state[symbol]['long']
                    state.update({
                        "price": Decimal(str(pos.entry_price)), "size": pos_size,
                        "value": pos_size * Decimal(str(pos.mark_price)) * cfg["contract_size"]
                    })
                    active_positions_set.add((symbol, side))
                    if position_state[symbol]['short']['size'] > 0: position_state[symbol]['short'] = get_default_pos_side_state()
                elif pos_size < 0:
                    side = 'short'
                    state = position_state[symbol]['short']
                    state.update({
                        "price": Decimal(str(pos.entry_price)), "size": abs(pos_size),
                        "value": abs(pos_size) * Decimal(str(pos.mark_price)) * cfg["contract_size"]
                    })
                    active_positions_set.add((symbol, side))
                    if position_state[symbol]['long']['size'] > 0: position_state[symbol]['long'] = get_default_pos_side_state()
        
        # APIÏóêÏÑú ÌôïÏù∏Îêú Ìè¨ÏßÄÏÖò Ïô∏ÏóêÎäî Î™®Îëê Ï≤≠ÏÇ∞Îêú Í≤ÉÏúºÎ°ú Í∞ÑÏ£ºÌïòÍ≥† Ï†ïÎ¶¨
        for symbol, sides in position_state.items():
            for side in ["long", "short"]:
                if (symbol, side) not in active_positions_set and sides[side]["size"] > 0:
                    log_debug(f"üîÑ ÏàòÎèô/ÏûêÎèô Ï≤≠ÏÇ∞ Í∞êÏßÄ ({symbol}_{side.upper()})", f"ÏÑúÎ≤Ñ: {sides[side]['size']}, API: ÏóÜÏùå")
                    set_manual_close_protection(symbol, side)
                    position_state[symbol][side] = get_default_pos_side_state()
                    if symbol in tpsl_storage: tpsl_storage[symbol][side].clear()

# ========
# 8. ÌïµÏã¨ ÏßÑÏûÖ Ï≤òÎ¶¨ Î°úÏßÅ
# ========
def handle_entry(data):
    symbol, side, base_type = normalize_symbol(data.get("symbol")), data.get("side", "").lower(), data.get("type", "normal")
    signal_type, entry_score = f"{base_type}_{side}", data.get("entry_score", 50)
    tv_tp_pct, tv_sl_pct = Decimal(str(data.get("tp_pct", "0")))/100, Decimal(str(data.get("sl_pct", "0")))/100
    
    if not all([symbol, side, data.get('price'), tv_tp_pct > 0, tv_sl_pct > 0]):
        return log_debug("‚ùå ÏßÑÏûÖ Î∂àÍ∞Ä", f"ÌïÑÏàò Ï†ïÎ≥¥ ÎàÑÎùΩ: {data}")
    
    cfg, current_price = get_symbol_config(symbol), get_price(symbol)
    signal_price = Decimal(str(data['price'])) / cfg.get("price_multiplier", Decimal("1.0"))
    if current_price <= 0: return
    
    update_all_position_states()
    state = position_state[symbol][side]
    
    if state["entry_count"] == 0 and abs(current_price - signal_price) > max(signal_price * PRICE_DEVIATION_LIMIT_PCT, Decimal(str(MAX_SLIPPAGE_TICKS)) * cfg['tick_size']):
        return log_debug(f"‚ö†Ô∏è Ï≤´ ÏßÑÏûÖ Ï∑®ÏÜå: Ïä¨Î¶¨ÌîºÏßÄ", f"Í∞ÄÍ≤©Ï∞® ÌÅº")
    
    entry_limits = {"premium": 5, "normal": 5, "rescue": 3}
    if state["entry_count"] >= sum(entry_limits.values()) or state[f"{base_type}_entry_count"] >= entry_limits.get(base_type, 99):
        return log_debug(f"‚ö†Ô∏è Ï∂îÍ∞Ä ÏßÑÏûÖ Ï†úÌïú", "ÏµúÎåÄ ÌöüÏàò ÎèÑÎã¨")
    
    current_signal_count = state[f"{base_type}_entry_count"] if "rescue" not in signal_type else 0
    qty, final_ratio = calculate_position_size(symbol, signal_type, entry_score, current_signal_count)
        
    if qty > 0 and place_order(symbol, side, qty):
        # ÏßÑÏûÖ ÏÑ±Í≥µ ÌõÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        state["entry_count"] += 1
        state[f"{base_type}_entry_count"] += 1
        state["entry_time"] = time.time()
        if "rescue" not in signal_type: state['last_entry_ratio'] = final_ratio
        
        # ‚ñº‚ñº‚ñº [Ï†úÏïà ÎìúÎ¶∞ Ï∂îÍ∞Ä Î°úÏßÅ] ÌîÑÎ¶¨ÎØ∏ÏóÑ TP Î∞∞Ïàò Ï†ÄÏû• ‚ñº‚ñº‚ñº
        current_multiplier = state.get("premium_tp_multiplier", Decimal("1.0"))
        
        if "premium" in signal_type:
            # Ï≤´ ÌîÑÎ¶¨ÎØ∏ÏóÑ ÏßÑÏûÖ (Í∏∞Ï°¥ Ìè¨ÏßÄÏÖò ÏóÜÏùå)
            if state["premium_entry_count"] == 1 and state["normal_entry_count"] == 0:
                new_multiplier = PREMIUM_TP_MULTIPLIERS["first_entry"]
            # ÏùºÎ∞ò ÏßÑÏûÖ ÌõÑ Ï≤´ ÌîÑÎ¶¨ÎØ∏ÏóÑ ÏßÑÏûÖ
            elif state["premium_entry_count"] == 1 and state["normal_entry_count"] > 0:
                new_multiplier = PREMIUM_TP_MULTIPLIERS["after_normal"]
            # ÌîÑÎ¶¨ÎØ∏ÏóÑ ÏßÑÏûÖ ÌõÑ Ï∂îÍ∞Ä ÌîÑÎ¶¨ÎØ∏ÏóÑ ÏßÑÏûÖ
            else:
                new_multiplier = PREMIUM_TP_MULTIPLIERS["after_premium"]
            
            # Í∏∞Ï°¥ Î∞∞ÏàòÏôÄ ÏÉà Î∞∞Ïàò Ï§ë Îçî Ïú†Î¶¨Ìïú(ÏûëÏùÄ) Í∞íÏùÑ ÏÑ†ÌÉùÌïòÏó¨ Ï†êÏßÑÏ†ÅÏúºÎ°ú TP Î™©ÌëúÎ•º ÎÇÆÏ∂§
            state["premium_tp_multiplier"] = min(current_multiplier, new_multiplier) if current_multiplier != Decimal("1.0") else new_multiplier
            log_debug(f"‚ú® ÌîÑÎ¶¨ÎØ∏ÏóÑ TP Î∞∞Ïàò Ï†ÅÏö©", f"{symbol} {side.upper()} ‚Üí {state['premium_tp_multiplier']:.2f}x")

        # ÏùºÎ∞ò/Î†àÏä§ÌÅê Ïã†Ìò∏Î°ú Ï≤´ ÏßÑÏûÖ Ïãú, Î∞∞Ïàò 1.0ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
        elif state["entry_count"] == 1:
            state["premium_tp_multiplier"] = Decimal("1.0")
        # ‚ñ≤‚ñ≤‚ñ≤ [Î°úÏßÅ Ï∂îÍ∞Ä ÏôÑÎ£å] ‚ñ≤‚ñ≤‚ñ≤

        store_tp_sl(symbol, side, tv_tp_pct, tv_sl_pct, state["entry_count"])
        log_debug(f"üíæ TP/SL Ï†ÄÏû•", f"TP: {tv_tp_pct*100:.3f}%, SL: {tv_sl_pct*100:.3f}%")
        log_debug(f"‚úÖ ÏßÑÏûÖ ÏÑ±Í≥µ", f"Ïú†Ìòï: {signal_type}, ÏàòÎüâ: {float(qty)}")

# ========
# 9. ÏõπÌõÖ ÎùºÏö∞Ìä∏ Î∞è Î∞±Í∑∏ÎùºÏö¥Îìú ÏûëÏóÖ
# ========
@app.route("/", methods=["POST"])
def webhook():
    try:
        data = json.loads(request.get_data(as_text=True))
        log_debug("üì¨ ÏõπÌõÖ ÏàòÏã†", f"Îç∞Ïù¥ÌÑ∞: {data}")
        if data.get("action") == "entry" and not is_duplicate(data):
            task_q.put_nowait(data)
        return "OK", 200
    except Exception as e:
        log_debug("‚ùå ÏõπÌõÖ Ïò§Î•ò", str(e), exc_info=True)
        return "Error", 500

@app.route("/ping", methods=["GET"])
def ping(): return "pong", 200

@app.route("/status", methods=["GET"])
def status():
    try:
        equity = get_total_collateral(force=True)
        update_all_position_states()
        active_positions = {}
        with position_lock:
            for symbol, sides in position_state.items():
                for side, pos_data in sides.items():
                    if pos_data["size"] != 0:
                        active_positions[f"{symbol}_{side.upper()}"] = {
                            "size": float(pos_data["size"]), "price": float(pos_data["price"]), "value": float(abs(pos_data["value"])),
                            "entry_count": pos_data["entry_count"], "normal_count": pos_data["normal_entry_count"],
                            "premium_count": pos_data["premium_entry_count"], "rescue_count": pos_data["rescue_entry_count"],
                            "last_ratio": float(pos_data['last_entry_ratio']),
                            # ‚ñº‚ñº‚ñº [Í∞úÏÑ†] Î™®ÎãàÌÑ∞ÎßÅÏùÑ ÏúÑÌïú Ï†ïÎ≥¥ Ï∂îÍ∞Ä ‚ñº‚ñº‚ñº
                            "premium_tp_mult": float(pos_data.get("premium_tp_multiplier", 1.0)),
                            "current_tp_pct": f"{float(pos_data.get('current_tp_pct', 0.0)) * 100:.4f}%"
                            # ‚ñ≤‚ñ≤‚ñ≤ [ÏàòÏ†ï ÏôÑÎ£å] ‚ñ≤‚ñ≤‚ñ≤
                        }
        return jsonify({"status": "running", "version": "v6.33-server", "balance_usdt": float(equity), "active_positions": active_positions})
    except Exception as e:
        return jsonify({"error": str(e)}), 500
    
async def price_monitor():
    uri = "wss://fx-ws.gateio.ws/v4/ws/usdt"
    symbols = list(SYMBOL_CONFIG.keys())
    while True:
        try:
            async with websockets.connect(uri, ping_interval=20, ping_timeout=10) as ws:
                await ws.send(json.dumps({"time": int(time.time()), "channel": "futures.tickers", "event": "subscribe", "payload": symbols}))
                log_debug("üîå ÏõπÏÜåÏºì Íµ¨ÎèÖ", f"{len(symbols)}Í∞ú Ïã¨Î≥º")
                while True:
                    msg = await asyncio.wait_for(ws.recv(), timeout=30)
                    result = json.loads(msg).get("result")
                    if isinstance(result, list): [simple_tp_monitor(i) for i in result]
                    elif isinstance(result, dict): simple_tp_monitor(result)
        except (asyncio.TimeoutError, websockets.exceptions.ConnectionClosed) as e:
            log_debug("üîå ÏõπÏÜåÏºì Ïû¨Ïó∞Í≤∞", f"ÏÇ¨Ïú†: {type(e).__name__}")
        except Exception as e: log_debug("üîå ÏõπÏÜåÏºì Ïò§Î•ò", str(e), exc_info=True)
        await asyncio.sleep(5)

def simple_tp_monitor(ticker):
    """üî• ÏßÑÏßú ÏµúÏ¢Ö ÏàòÏ†ï: 'reduce_only=True' ÏòµÏÖòÏùÑ Ï∂îÍ∞ÄÌïòÏó¨ Ìó§ÏßÄ Î™®ÎìúÏóêÏÑú TPÍ∞Ä Î∞òÎåÄ Ìè¨ÏßÄÏÖòÏùÑ Ïó¨Îäî ÏπòÎ™ÖÏ†ÅÏù∏ Î≤ÑÍ∑∏Î•º Ìï¥Í≤∞"""
    try:
        symbol = normalize_symbol(ticker.get("contract"))
        price = Decimal(str(ticker.get("last", "0")))
        
        if not symbol or price <= 0: return
        cfg = get_symbol_config(symbol)
        if not cfg: return
            
        with position_lock:
            pos_side_state = position_state.get(symbol, {})
            
            # --- Î°± Ìè¨ÏßÄÏÖò TP Ï≤¥ÌÅ¨ ---
            long_actual_size = pos_side_state.get("long", {}).get("size", Decimal(0))
            if long_actual_size > 0 and not is_manual_close_protected(symbol, "long"):
                long_pos = pos_side_state["long"]
                entry_price = long_pos.get("price")
                entry_count = long_pos.get("entry_count", 0)

                if entry_price and entry_price > 0 and entry_count > 0:
                    premium_multiplier = long_pos.get("premium_tp_multiplier", Decimal("1.0"))
                    symbol_weight_tp = Decimal(str(cfg["tp_mult"]))
                    tp_map = [Decimal("0.0045"), Decimal("0.004"), Decimal("0.0035"), Decimal("0.003"), Decimal("0.002")]
                    base_tp_pct = tp_map[min(entry_count-1, len(tp_map)-1)] * symbol_weight_tp * premium_multiplier
                    time_elapsed = time.time() - long_pos.get("entry_time", time.time())
                    periods_15s = max(0, int(time_elapsed / 15))
                    tp_decay_amt_ps = Decimal("0.002") / 100
                    tp_min_pct_ps = Decimal("0.16") / 100
                    tp_reduction = Decimal(str(periods_15s)) * (tp_decay_amt_ps * symbol_weight_tp * premium_multiplier)
                    min_tp_with_mult = tp_min_pct_ps * symbol_weight_tp * premium_multiplier
                    current_tp_pct = max(min_tp_with_mult, base_tp_pct - tp_reduction)
                    long_pos["current_tp_pct"] = current_tp_pct
                    tp_price = entry_price * (1 + current_tp_pct)
                    
                    if price >= tp_price:
                        set_manual_close_protection(symbol, 'long', duration=20)
                        log_debug(f"üéØ Î°± TP Ïã§Ìñâ ({symbol})", f"ÏßÑÏûÖÍ∞Ä: {entry_price:.8f}, ÌòÑÏû¨Í∞Ä: {price:.8f}, TPÍ∞Ä: {tp_price:.8f}")
                        
                        try:
                            # ‚ñº‚ñº‚ñº [ÌïµÏã¨ ÏàòÏ†ï] reduce_only=True ÌîåÎûòÍ∑∏Î•º Ï∂îÍ∞ÄÌïòÏó¨ 'Ï≤≠ÏÇ∞ Ï†ÑÏö©' Ï£ºÎ¨∏ÏúºÎ°ú Ï†ÑÏÜ° ‚ñº‚ñº‚ñº
                            order = FuturesOrder(contract=symbol, size=-int(long_actual_size), price="0", tif="ioc", reduce_only=True)
                            result = _get_api_response(api.create_futures_order, SETTLE, order)
                            if result:
                                log_debug(f"‚úÖ Î°± TP Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ ÏÑ±Í≥µ ({symbol})", f"ID: {getattr(result, 'id', 'Unknown')}")
                                position_state[symbol]['long'] = get_default_pos_side_state()
                                if symbol in tpsl_storage: tpsl_storage[symbol]['long'].clear()
                                log_debug(f"üîÑ TP Ïã§Ìñâ ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å ({symbol}_long)")
                            else:
                                log_debug(f"‚ùå Î°± TP Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ Ïã§Ìå® ({symbol})", "API Ìò∏Ï∂ú Ïã§Ìå®. 20Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ Í∞ÄÎä•.")
                        except Exception as e:
                            log_debug(f"‚ùå Î°± TP Ï≤≠ÏÇ∞ Ïò§Î•ò ({symbol})", str(e), exc_info=True)

            # --- Ïàè Ìè¨ÏßÄÏÖò TP Ï≤¥ÌÅ¨ ---
            short_actual_size = pos_side_state.get("short", {}).get("size", Decimal(0))
            if short_actual_size > 0 and not is_manual_close_protected(symbol, "short"):
                short_pos = pos_side_state["short"]
                entry_price = short_pos.get("price")
                entry_count = short_pos.get("entry_count", 0)

                if entry_price and entry_price > 0 and entry_count > 0:
                    premium_multiplier = short_pos.get("premium_tp_multiplier", Decimal("1.0"))
                    symbol_weight_tp = Decimal(str(cfg["tp_mult"]))
                    tp_map = [Decimal("0.005"), Decimal("0.004"), Decimal("0.0035"), Decimal("0.003"), Decimal("0.002")]
                    base_tp_pct = tp_map[min(entry_count-1, len(tp_map)-1)] * symbol_weight_tp * premium_multiplier
                    time_elapsed = time.time() - short_pos.get("entry_time", time.time())
                    periods_15s = max(0, int(time_elapsed / 15))
                    tp_decay_amt_ps = Decimal("0.002") / 100
                    tp_min_pct_ps = Decimal("0.16") / 100
                    tp_reduction = Decimal(str(periods_15s)) * (tp_decay_amt_ps * symbol_weight_tp * premium_multiplier)
                    min_tp_with_mult = tp_min_pct_ps * symbol_weight_tp * premium_multiplier
                    current_tp_pct = max(min_tp_with_mult, base_tp_pct - tp_reduction)
                    short_pos["current_tp_pct"] = current_tp_pct
                    tp_price = entry_price * (1 - current_tp_pct)
                    
                    if price <= tp_price:
                        set_manual_close_protection(symbol, 'short', duration=20)
                        log_debug(f"üéØ Ïàè TP Ïã§Ìñâ ({symbol})", f"ÏßÑÏûÖÍ∞Ä: {entry_price:.8f}, ÌòÑÏû¨Í∞Ä: {price:.8f}, TPÍ∞Ä: {tp_price:.8f}")
                        
                        try:
                            # ‚ñº‚ñº‚ñº [ÌïµÏã¨ ÏàòÏ†ï] reduce_only=True ÌîåÎûòÍ∑∏Î•º Ï∂îÍ∞ÄÌïòÏó¨ 'Ï≤≠ÏÇ∞ Ï†ÑÏö©' Ï£ºÎ¨∏ÏúºÎ°ú Ï†ÑÏÜ° ‚ñº‚ñº‚ñº
                            order = FuturesOrder(contract=symbol, size=int(short_actual_size), price="0", tif="ioc", reduce_only=True)
                            result = _get_api_response(api.create_futures_order, SETTLE, order)
                            if result:
                                log_debug(f"‚úÖ Ïàè TP Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ ÏÑ±Í≥µ ({symbol})", f"Ï£ºÎ¨∏ ID: {getattr(result, 'id', 'Unknown')}")
                                position_state[symbol]['short'] = get_default_pos_side_state()
                                if symbol in tpsl_storage: tpsl_storage[symbol]['short'].clear()
                                log_debug(f"üîÑ TP Ïã§Ìñâ ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å ({symbol}_short)")
                            else:
                                log_debug(f"‚ùå Ïàè TP Ï≤≠ÏÇ∞ Ï£ºÎ¨∏ Ïã§Ìå® ({symbol})", "API Ìò∏Ï∂ú Ïã§Ìå®. 20Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ Í∞ÄÎä•.")
                        except Exception as e:
                            log_debug(f"‚ùå Ïàè TP Ï≤≠ÏÇ∞ Ïò§Î•ò ({symbol})", str(e), exc_info=True)
                
    except Exception as e:
        log_debug(f"‚ùå TP Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò ({ticker.get('contract', 'Unknown')})", str(e))

def worker(idx):
    while True:
        try: handle_entry(task_q.get(timeout=60))
        except queue.Empty: continue
        except Exception as e: log_debug(f"‚ùå ÏõåÏª§-{idx} Ïò§Î•ò", str(e), exc_info=True)

def position_monitor():
    while True:
        time.sleep(30)
        try:
            update_all_position_states()
            log_debug("üìä Ìè¨ÏßÄÏÖò ÌòÑÌô©", "Ï£ºÍ∏∞Ï†Å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
        except Exception as e: log_debug("‚ùå Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò", str(e), exc_info=True)

if __name__ == "__main__":
    log_debug("üöÄ ÏÑúÎ≤Ñ ÏãúÏûë", "Gate.io ÏûêÎèôÎß§Îß§ ÏÑúÎ≤Ñ v6.33-server")
    log_debug("üõ°Ô∏è ÏïàÏ†ÑÏû•Ïπò", f"ÏõπÌõÖ Ï§ëÎ≥µ Î∞©ÏßÄ Ïø®Îã§Ïö¥: {COOLDOWN_SECONDS}Ï¥à")
    initialize_states()
    log_debug("üí∞ Ï¥àÍ∏∞ ÏûêÏÇ∞", f"{get_total_collateral(force=True):.2f} USDT")
    update_all_position_states()
    threading.Thread(target=position_monitor, daemon=True).start()
    threading.Thread(target=lambda: asyncio.run(price_monitor()), daemon=True).start()
    for i in range(WORKER_COUNT): threading.Thread(target=worker, args=(i,), daemon=True).start()
    port = int(os.environ.get("PORT", 8080))
    log_debug("üåê Ïõπ ÏÑúÎ≤Ñ ÏãúÏûë", f"0.0.0.0:{port} ÎåÄÍ∏∞ Ï§ë...")
    app.run(host="0.0.0.0", port=port, debug=False, threaded=True)
